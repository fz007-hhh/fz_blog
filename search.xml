<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu配置ssh</title>
    <url>/sni2r9/</url>
    <content><![CDATA[<p>在 Ubuntu 上配置 SSH 以便使用 Visual Studio Code (VSCode) 进行连接，可以按照以下步骤进行：</p>
<h3 id="1-安装-OpenSSH-服务器"><a href="#1-安装-OpenSSH-服务器" class="headerlink" title="1. 安装 OpenSSH 服务器"></a>1. 安装 OpenSSH 服务器</h3><p>首先，你需要确保你的 Ubuntu 系统上安装了 OpenSSH 服务器。打开终端，执行以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install openssh-server</span><br></pre></td></tr></table></figure></div>

<h3 id="2-启动和启用-SSH-服务"><a href="#2-启动和启用-SSH-服务" class="headerlink" title="2. 启动和启用 SSH 服务"></a>2. 启动和启用 SSH 服务</h3><p>安装完成后，启动 SSH 服务并确保它在系统启动时自动启动：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start ssh</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ssh</span><br></pre></td></tr></table></figure></div>

<h3 id="3-检查-SSH-服务状态"><a href="#3-检查-SSH-服务状态" class="headerlink" title="3. 检查 SSH 服务状态"></a>3. 检查 SSH 服务状态</h3><p>你可以使用以下命令检查 SSH 服务的状态：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status ssh</span><br></pre></td></tr></table></figure></div>

<p>确保服务正在运行，并且没有错误信息。</p>
<h3 id="4-配置-SSH（可选）"><a href="#4-配置-SSH（可选）" class="headerlink" title="4. 配置 SSH（可选）"></a>4. 配置 SSH（可选）</h3><p>默认情况下，SSH 使用的配置文件位于 <code>/etc/ssh/sshd_config</code>。你可以根据需要修改此文件以增强安全性，例如禁用密码登录，启用密钥登录等。编辑配置文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></div>

<p>以下是一些常见的配置选项：</p>
<ul>
<li><p><strong>禁用密码登录</strong>（仅允许使用密钥登录）：</p>
 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>更改默认 SSH 端口</strong>（可选）：</p>
 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port 2222</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>更改后，保存并退出编辑器。然后重新启动 SSH 服务以使更改生效：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart ssh</span><br></pre></td></tr></table></figure></div>

<h3 id="5-配置防火墙（如果适用）"><a href="#5-配置防火墙（如果适用）" class="headerlink" title="5. 配置防火墙（如果适用）"></a>5. 配置防火墙（如果适用）</h3><p>如果你的系统启用了防火墙，确保 SSH 端口（默认是 22 或你更改后的端口）是开放的。使用以下命令允许 SSH 通过 UFW（如果你使用 UFW 作为防火墙）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow ssh</span><br><span class="line"><span class="comment"># 如果你更改了端口，例如使用 2222：</span></span><br><span class="line"><span class="comment"># sudo ufw allow 2222</span></span><br></pre></td></tr></table></figure></div>

<h3 id="6-获取服务器的-IP-地址"><a href="#6-获取服务器的-IP-地址" class="headerlink" title="6. 获取服务器的 IP 地址"></a>6. 获取服务器的 IP 地址</h3><p>你可以使用以下命令获取你的服务器的 IP 地址：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure></div>

<h3 id="7-在-VSCode-中配置-SSH"><a href="#7-在-VSCode-中配置-SSH" class="headerlink" title="7. 在 VSCode 中配置 SSH"></a>7. 在 VSCode 中配置 SSH</h3><ol>
<li><p><strong>安装 Remote - SSH 插件</strong>：</p>
<ul>
<li>打开 VSCode。</li>
<li>转到扩展视图 (<code>Ctrl + Shift + X</code>)。</li>
<li>搜索并安装 <strong>Remote - SSH</strong> 插件。</li>
</ul>
</li>
<li><p><strong>添加 SSH 主机</strong>：</p>
<ul>
<li><p>按 <code>F1</code> 或 <code>Ctrl + Shift + P</code> 打开命令面板。</p>
</li>
<li><p>输入并选择 <strong>Remote-SSH: Add New SSH Host</strong>。</p>
</li>
<li><p>输入你的 SSH 连接命令，例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh username@server_ip</span><br></pre></td></tr></table></figure></div>

<p>替换 <code>username</code> 和 <code>server_ip</code> 为你的实际用户名和服务器的 IP 地址。</p>
</li>
</ul>
</li>
<li><p><strong>选择 SSH 配置文件</strong>：</p>
<ul>
<li>VSCode 会提示你选择 SSH 配置文件，通常是 <code>~/.ssh/config</code>。</li>
</ul>
</li>
<li><p><strong>连接到 SSH 主机</strong>：</p>
<ul>
<li>重新打开命令面板，输入并选择 <strong>Remote-SSH: Connect to Host</strong>，然后选择你刚刚添加的主机。</li>
</ul>
</li>
<li><p><strong>输入密码或密钥</strong>（如果使用密码）：</p>
<ul>
<li>如果 SSH 配置为密码验证，你需要输入密码。如果配置为密钥验证且密钥已设置为默认，VSCode 会自动使用密钥。</li>
</ul>
</li>
</ol>
<h3 id="8-连接后"><a href="#8-连接后" class="headerlink" title="8. 连接后"></a>8. 连接后</h3><p>一旦连接成功，你就可以像在本地一样编辑远程服务器上的文件了。你可以打开终端，运行命令，并使用 VSCode 的所有功能。</p>
<p>通过以上步骤，你就可以方便地在 Ubuntu 上配置 SSH，以便使用 VSCode 进行连接和远程开发。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>大模型算力是如何计算的</title>
    <url>/sni2x9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>多模态</category>
      </categories>
      <tags>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7 基础命令爆出255返回码</title>
    <url>/sni2sz/</url>
    <content><![CDATA[<p>cron 是一个用于在指定时间自动执行预定任务的守护进程，&#x2F;etc&#x2F;cron.hourly&#x2F; 目录中的脚本每小时会被 cron进程 自动执行一次</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置静态IP</title>
    <url>/sni2qz/</url>
    <content><![CDATA[<p>在 Ubuntu 22.04 中配置静态 IP 地址的方法如下：<br><strong>这里请注意！！静态IP的地址不要设重复了！！即使是删除过的虚拟机也不要与之重复！！</strong></p>
<h3 id="1-修改-Netplan-配置文件"><a href="#1-修改-Netplan-配置文件" class="headerlink" title="1. 修改 Netplan 配置文件"></a>1. 修改 Netplan 配置文件</h3><p>Ubuntu 22.04 使用 Netplan 来管理网络配置。你需要找到并编辑适当的配置文件，通常位于 <code>/etc/netplan/</code> 目录下。打开终端，执行以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /etc/netplan/</span><br></pre></td></tr></table></figure></div>

<p>比如这里查找到了 <code>01-network-manager-all.yaml</code>，那么使用root用户执行如下语句，修改代码</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/netplan/01-network-manager-all.yaml</span><br></pre></td></tr></table></figure></div>

<p>（文件名可能有所不同，根据实际情况选择）</p>
<h3 id="2-配置静态-IP"><a href="#2-配置静态-IP" class="headerlink" title="2. 配置静态 IP"></a>2. 配置静态 IP</h3><p>在打开的 YAML 文件中，找到对应的网络接口（例如 <code>ens33</code>），并按照以下格式进行修改：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">NetworkManager</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">ens33:</span>  <span class="comment"># 替换为你的网络接口名称</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">addresses:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.130</span><span class="number">.9</span><span class="string">/24</span>  <span class="comment"># 替换为你要设置的静态 IP 地址</span></span><br><span class="line">      <span class="attr">gateway4:</span> <span class="number">192.168</span><span class="number">.130</span><span class="number">.2</span>  <span class="comment"># 替换为你的网关地址</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.130</span><span class="number">.2</span>  <span class="comment"># 使用 Google 的公共 DNS</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-应用配置"><a href="#3-应用配置" class="headerlink" title="3. 应用配置"></a>3. 应用配置</h3><p>保存文件并退出编辑器（在 nano 中，使用 <code>Ctrl + O</code> 保存，然后 <code>Ctrl + X</code> 退出）。接下来，执行以下命令应用新的网络配置：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netplan apply</span><br></pre></td></tr></table></figure></div>

<h3 id="4-验证配置"><a href="#4-验证配置" class="headerlink" title="4. 验证配置"></a>4. 验证配置</h3><p>你可以使用以下命令验证 IP 配置：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure></div>

<p>确认你的静态 IP 地址已经正确配置。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>确保你配置的 IP 地址在你的网络范围内，并且没有与其他设备冲突。</li>
<li>如果你在使用图形界面，可以通过网络设置界面进行相应的更改。</li>
</ul>
<p>按照这些步骤，你就可以在 Ubuntu 22.04 中成功配置静态 IP 地址已经正确配置。</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和+差分</title>
    <url>/sni2z0/</url>
    <content><![CDATA[<p>前缀和对我来说已经不算陌生了，前缀和的方便之处在于可以 <strong>快速求解任意子数组之和</strong>。但是，前缀和在区间频繁修改时就显得较为羸弱了，因为它只适合求和，不擅长修改。</p>
<p>那么，如果某些<strong>区间频繁修改</strong>（<strong>仅限于都增加或者都减少某个值</strong>），但是求和只有一次，这种时候首先会想到的就是<strong>线段树</strong>了，不过线段树的代码量太多，使用差分则更简单，也更快。</p>
<h1 id="什么是差分？"><a href="#什么是差分？" class="headerlink" title="什么是差分？"></a>什么是差分？</h1><p>差分的意思主要是这个 <strong>差</strong>，指的其实就是 <strong>元素差</strong>。</p>
<p>前缀和的思想是动态规划，可以将前 n 个元素的和预先存储起来，这样计算区间和的时候就不需要再按需进行累加了。</p>
<p>而差分的思想就是 <strong>先求出相邻元素之间的差</strong>，当需要某个区间<code>[a,b] </code>增加或者减少某个值的，只需要修改 <code>arr[a]</code> 和 <code>arr[b+1]</code>，然后重新计算一次前缀和就可以了。</p>
<h2 id="一维数组差分"><a href="#一维数组差分" class="headerlink" title="一维数组差分"></a>一维数组差分</h2><p>如果有一个数组 <code>[1, 2, 3, 4, 5]</code>，其差分数组为 <code>[1, 1, 1, 1, 1]</code>。如果要将区间 <code>[1, 3]</code> 中的每个元素增加 2，可以通过修改差分数组 <code>diff[1] += 2</code> 和<code>diff[4] -= 2</code>来实现，得到新的差分数组<code> [1, 3, 1, 1, -1]</code>。通过重建数组可以得到<code> [1, 4, 5, 6, 5]</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/a5d44b1e910f2d6038dc34fc3a64086.jpg"
                      alt="a5d44b1e910f2d6038dc34fc3a64086.jpg"
                ></p>
<h2 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h2><p>刚才只是在一维数组上差分，实现起来还是比较简单的，如果我们是在树上进行差分呢？<br>树上差分刚才只是在一维数组上差分，实现起来还是比较简单的，如果我们是在树上进行差分呢？</p>
<p>场景：现在给你一颗树，并且告诉你起始节点和结束节点，对起始节点和结束节点路径中的所有节点的值都加上value。需要注意的是，<strong>这里的树指的是一颗无向树，也就是说并不是像只能从父节点向子节点的那种遍历，只要是这个节点连接到的结点，都是可以遍历到的。</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/05ca61d668ebe7e80a7514d8888ee46.jpg"
                      alt="05ca61d668ebe7e80a7514d8888ee46.jpg"
                ></p>
<p>如果要使用树上差分，就必不可免要使用到树中节点的 <strong>最近公共祖先</strong> 求解算法。[[最近公共祖先（LCA)]] 。关于LCA的求解推荐使用倍增法，可以详细看看。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/06223d47370e6ef8ba55e63bc42ef1c.jpg"
                      alt="06223d47370e6ef8ba55e63bc42ef1c.jpg"
                ><br>如图所示，实现差分我们只需要修改四个点的权值，起始点和终结点就不用说了，关键是这个 <strong>LCA还有LCA的父节点</strong>。这里你可能会有如下问题：</p>
<blockquote>
<p>[!note]<br>为什么这里还要将LCA的父节点权值也下降？</p>
<p>原因是我们<strong>从根节点1开始进行DFS</strong>，原本的前缀和在这里更像“后缀和”。<br>DFS的过程中，每个节点的权值更新为其所有子孙的权值总和，weight[i]&#x3D;$\sum_i^n{weight[son]}$ </p>
<p><strong>对于LCA本身，其本身只需要+3，不过a和b都是他的子孙，所以其本身-3</strong>。对于LCA的父节点，他的权值应该是不变的，刚才LCA减去3是因为LCA要+3，但是LCA的父节点应该是不变的，因此LCA的父节点权值也需要下降。</p>
</blockquote>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="type">int</span> <span class="title">maxRemoval</span><span class="params">(vector &lt; <span class="type">int</span> &gt; &amp; nums, vector &lt; vector &lt; <span class="type">int</span> &gt;&gt; &amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort(queries.begin(), queries.end(), [](vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b)&#123;</span></span><br><span class="line">        <span class="comment">//     if (a[0]!=b[0])</span></span><br><span class="line">        <span class="comment">//         return a[0]&lt;b[0];</span></span><br><span class="line">        <span class="comment">//     else</span></span><br><span class="line">        <span class="comment">//         return a[1]&gt;b[1];</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="built_in">sort</span>(queries.<span class="built_in">begin</span>(), queries.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        vector &lt; <span class="type">int</span> &gt; <span class="built_in">diff</span>(n + <span class="number">1</span>);</span><br><span class="line">        LL sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        priority_queue &lt; <span class="type">int</span> &gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; queries.<span class="built_in">size</span>() &amp;&amp; queries[j][<span class="number">0</span>] &lt;= i) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(queries[j][<span class="number">1</span>]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sum + diff[i] &lt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pq.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (pq.<span class="built_in">top</span>() &lt; i) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="type">int</span> t = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">                diff[t + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queries.<span class="built_in">size</span>() - ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Leetcode/动态规划</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>UAV-Aided Computation Offloading in Mobile-Edge Computing Networks_ A Stackelberg Game Approach</title>
    <url>/sni2ya/</url>
    <content><![CDATA[<blockquote>
<p>[!note]<br>基于斯塔克伯格博弈方法，在无人机辅助的移动边缘计算网络中实现有效的计算任务卸载。</p>
<p><strong>计算卸载</strong>是指将移动设备上的计算任务转移到网络中的其他计算能力更强的节点（如边缘服务器）上进行处理的过程。无人机在这里的作用可能是作为移动的边缘服务器，或者作为中继节点，帮助将计算任务从用户设备卸载到更远的服务器。</p>
</blockquote>
<p>无人机（UAVs）被认为是为移动用户（MUs）提供额外计算能力和广泛覆盖的一种有前景的方法，特别是当 MUs 不在基础设施的通信范围内时。在本文中，研究了一个包括一个 UAV-MEC 服务器、一个 BS-MEC 服务器和多个 MUs 的 UAV 辅助移动边缘计算（MEC）网络，用于计算卸载，其中边缘服务提供商（ESP）管理两种服务器。考虑到 MUs 有大量计算任务需要执行，而 ESP 拥有空闲的计算资源。MUs 可以选择将他们的任务卸载到 ESP 以减轻压力和成本，ESP 可以通过出售计算资源来获得利润。</p>
<p><strong>ESP 和 MUs 之间的互动被建模为斯塔克伯格博弈</strong>，双方都希望最大化自己的效用。使用逆向归纳法分析了所提出的博弈，并证明了游戏中可以实现唯一的<strong>纳什均衡</strong>。然后，提出了一种<strong>基于梯度的动态迭代搜索算法（GDISA）</strong> 来获得近似最优解。最后，通过广泛的模拟验证了 GDISA 的有效性，结果表明 GDISA 在不同场景下的表现优于其他基准方法。</p>
<blockquote>
<p>[!note]<br>这里不用关心无人机的作用是什么，其实只需要知道 <strong>服务提供商</strong> 和 <strong>移动用户</strong>（MUs)，用户需要使用商家的服务来降低自己这边的计算任务压力，商家需要尽可能的售卖空闲计算资源以牟取利润。</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>随着物联网（IoT）技术的发展，各种 IoT 设备可以相互协作，实现万物互联的目标[1]，[2]。与此同时，随着 IoT 设备的普及和技术的进步，IoT 已经为计算密集型功能开辟了许多应用领域，例如智能交通系统、智能医疗、在线互动游戏等[3]，[4]。然而，由于能耗和计算资源的限制，当前的 IoT 设备不可避免地无法支持这些计算密集型应用[5]，[6]。</p>
<p>为了提高设备的计算能力，移动云计算（MCC）已成为一种有前景的方式。<strong>计算任务被卸载到资源丰富的云数据中心执行，从而克服了设备的存储容量和计算资源的限制</strong>[7]，[8]。然而，对于某些延迟敏感的 IoT 服务来说，MCC 并不理想，因为云处理中的长传输距离导致了额外的传输成本和延迟。<strong>最近，移动边缘计算（MEC）已成为处理计算密集型任务的 5G 架构的关键组成部分</strong>[9]，[10]。<strong>通过设置 MEC 服务器，移动用户（MUs）的工作负载可以迁移到附近的边缘服务器，同时提高设备的服务质量（QoS）并显著降低能耗和延迟</strong>[11]，[12]。然而，MEC 可能不适用于某些基础设施有限的通信场景，例如紧急救援、军事演习、灾难响应等。在这些情况下，许多地面通信设施可能由于这些原因而损坏，因此无法提供通信和计算服务。</p>
<p>幸运的是，无人机（UAV）可以用来协助 MEC 进行通信和计算，这已成为应对这一挑战的关键技术之一[13]。因此，本文引入了一个 UAV 辅助的 MEC 系统，在这个系统中，多个 MUs 位于基站的覆盖区域内，每个基站都配备了一个<strong>边缘服务器（例如，BS-MEC 服务器）</strong>。MUs 可以本地执行他们的任务，或者将它们卸载到 BS-MEC 服务器。假设由于某些原因（如自然灾害或军事攻击）一个基站失败。在这种情况下，<strong>受损的 BS-MEC 服务器可能长时间无法提供服务</strong>，因此一些受影响的 MUs 将继续在目标区域搜索蜂窝信号。这不可避免地增加了未受损 BS-MEC 服务器的压力。因此，<strong>本文引入了一个飞行的 UAV（即，UAV-MEC 服务器），它具有通信和计算能力，以为这些受影响的 MUs 提供服务，并分担未受损 BS-MEC 服务器的压力</strong>，直到部署新的 BS-MEC 服务器为止。此外，<strong>引入了边缘服务提供商（ESP）来管理 BS-MEC 和 UAV-MEC 服务器</strong>。</p>
<p>目前，一些研究已经研究了 UAV 辅助 MEC 系统中的计算卸载。他们的目标大多是改善系统的 QoS（例如，成本、延迟、能耗等）。然而，任务卸载的过程将不可避免地消耗一些通信和计算资源。从经济角度来看，考虑到 <strong>ESP 是自私和理性的，如果没有补偿，它将不会参与任务卸载过程</strong>。因此，迫切需要<strong>开发激励机制来激励 ESP 参与任务卸载过程</strong>[14]，[15]。 幸运的是，博弈论可以用来模拟自私和独立参与者之间的互动过程，以便所有参与游戏的参与者都能获得最大奖励。特别是，可以通过斯塔克伯格博弈来研究个体理性参与者之间的竞争和合作，其中参与者被分为领导者和追随者。然而，据我们所知，UAV 辅助 MEC 系统中斯塔克伯格博弈的设计尚未得到很好的研究。本文考虑了 <strong>MUs 有一些任务需要执行，ESP 拥有空闲的计算资源。MUs 可以选择将任务卸载到 ESP 以减轻他们的压力和成本，而 ESP 可以通过出售闲置计算资源来获得利润</strong>。特别是，ESP 和 MUs 之间的互动过程通过斯塔克伯格博弈进行建模，<strong>其中 ESP 是领导者，MUs 是追随者</strong>。然后，本文提出了一种基于梯度的算法来获得近似最优解，以最大化 ESP 和 MUs 的效用。主要贡献如下：<br>1）我们研究了一个重要的计算卸载问题，即在 UAV 辅助的移动边缘网络场景中，有一个 UAV-MEC 服务器，一个 BS-MEC 服务器和多个 MUs，其中 ESP 管理两种服务器。<br>2）我们使用斯塔克伯格博弈来建模 ESP 和 MUs 之间的互动过程，其中 ESP 是领导者，MUs 是追随者。优化目标是最大化 ESP 和 MUs 的效用。<br>3）我们使用逆向归纳法分析所提出的斯塔克伯格博弈，并证明了 ESP 和 MUs 之间存在唯一的纳什均衡。接下来，设计了一种基于梯度的动态迭代搜索算法（GDISA）来获得近似最优解。<br>4）通过广泛的模拟评估了所提出的模型和算法的有效性。</p>
<p>本文的其余部分如下介绍。第 II 节回顾了相关工作，第 III 节介绍了系统模型。然后，在第 IV 节中描述和分析了所提出的博弈问题。第 V 节提出了所提出的算法。第 VI 节评估和分析了 GDISA 的性能。在第 VIII 节中，本文得出结论。</p>
<blockquote>
<p>[!note]<br>现在可以知道无人机UAV起到的作用，原本地面上的是BS-MEC服务器，如果某个BS-MEC服务器因为军事或者自然原因损坏，那么可以启动无人机作为一个临时的服务器，知道损坏的BS-MEC修好。<br>不过这些不是很关键，关键的是需要一个策略，一方面在激发ESP提供服务的时候保证其获利；另一方面尽可能的降低MUs购买计算资源的成本。这里使用的就是stackelberg博弈解决问题，并且使用基于梯度的动态迭代搜索算法获取近似解。</p>
</blockquote>
<h2 id="Relate-Works"><a href="#Relate-Works" class="headerlink" title="Relate Works"></a>Relate Works</h2><p><strong>相关工作</strong></p>
<p>A. 移动边缘计算中的计算卸载</p>
<p>最近，移动边缘计算（MEC）中的计算卸载研究受到了广泛的关注，包括学术界和工业界。它们中的大多数目标是减少延迟[16]，[17]，[18]，减少能耗[19]，[20]，或平衡能耗和延迟之间的权衡[21]，[22]。Feng等人[17]提出了一种基于车辆边缘计算的反向卸载框架，通过充分利用车辆计算资源进一步降低系统延迟。Chen等人[19]构建了一个节能资源分配方案，同时考虑了延迟、信道质量和传输功率的约束，旨在最小化任务卸载的能耗。Zhou等人[22]考虑了基于边缘计算的智能电网中的优化问题，目标是最小化任务成本，即时间和能耗消耗的加权和。</p>
<p>B. 无人机辅助的边缘计算</p>
<p>无人机已经在不同领域得到广泛应用，特别是协助地面通信和计算。实际上，通过使用无人机作为空中基站，这是增强现有通信系统覆盖范围和工作效率的有前途的方法[23]。Vamvakas等人[24]引入了一个框架，其中无人机被用作基站，以补充宏基站，并为MUs提供高效且无干扰的通信。Zhang等人[25]研究了无人机的比特分配、时间分配、功率分配和轨迹设计，目标是最小化无人机的总能耗。Liu等人[26]通过联合优化无人机的CPU频率、负载卸载、传输功率和轨迹，最小化了无人机的能耗。一些研究考虑了由无人机支持的MEC系统。Yu等人[27]联合优化了无人机的位置、通信和计算资源分配，以最小化MUs的服务延迟加权和和无人机的能耗。Han等人[28]开发了一个由无人机辅助的MEC系统，其中无人机从MUs收集数据，然后将其传输到基于MEC的接入点进行计算。Liu等人[29]提出了一个基于无人机的协作MEC网络架构，其中无人机可以相互协助执行计算任务，并开发了一个优化问题，以实现最佳的计算资源分配和计算卸载策略。通常，卸载任务的时间限制和能耗将成为UAV辅助MEC系统中的一个挑战性问题。Zhou等人[30]研究了在UAV辅助MEC无线电源系统中的计算速率最大化问题，考虑了能量收集的因果性和无人机速度约束。Zhang等人[31]考虑了MUs和无人机的平均加权能耗，并研究了资源分配、计算卸载和飞行轨迹调度的联合优化问题。为了最小化卸载任务的延迟，Cao等人[32]研究了联合无人机轨迹调度和计算卸载问题。</p>
<p>C. 博弈论</p>
<p>几种基于经济理论的方法已经被应用于激励各方参与计算卸载过程[33]。特别是，由于参与者需要被鼓励相互合作以实现他们的目标，我们可以使用博弈论来分析自私和独立实体之间的互动[34]。Zhang等人[35]开发了一种基于博弈论的解决方案，以最小化UAV辅助MEC系统中能耗和延迟的加权成本。Messous等人[36]考虑了将无人机的任务卸载到远程边缘服务器，然后提出了一个非合作博弈来解决能耗、延迟和成本之间的最佳权衡。Zhao等人[37]提出了一个无人机辅助车辆计算卸载优化框架，并将卸载决策问题表述为多人顺序博弈，以最小化系统成本。此外，可以通过使用斯塔克伯格博弈来研究理性参与者之间的合作和冲突。Zeng等人[38]提出了一个志愿者辅助车辆边缘计算模型和基于斯塔克伯格博弈的方法，以最大化志愿者车辆的奖励。Chang和Wei[39]提出了一种基于斯塔克伯格博弈的方法来研究边缘服务器的效用最大化问题和云的最优定价。为了最大化云服务器和边缘服务器的效用，我们之前的工作[40]提出了一种基于斯塔克伯格博弈的计算卸载方法在云边缘网络中。与现有研究相比，在我们的场景中，我们考虑MUs有一些计算任务需要卸载到ESP，其中ESP管理UAV-MEC服务器和BS-MEC服务器。我们使用斯塔克伯格博弈来建模ESP和MUs之间的互动过程，目标是最大化ESP和MUs的效用，其中ESP是领导者，MUs是追随者。此外，还考虑了计算任务的执行时间限制和无人机的能耗。</p>
<h2 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h2><p><strong>系统模型</strong></p>
<p>本文考虑了一个用于计算卸载的UAV辅助MEC网络。图1显示了系统模型，其中包括一个UAV-MEC服务器、一个BS-MEC服务器和N个MUs，UAV-MEC和BS-MEC服务器由ESP管理。每个MU需要执行延迟敏感和计算密集型任务，这些资源受限的MU可以选择将计算任务卸载到ESP以减轻他们的负担。然后，ESP将收取相应的费用以确保自己的利益。Hi ≜ {Li, Bi, tmax i }用于表示由MU i ∈ {1, 2, …, N}生成的任务，<strong>其中Li表示任务Hi的大小，Bi表示完成Hi所需的总CPU周期数，tmax i 表示Hi的时间约束。</strong> 类似于[41]，不同类型的应用程序可能需要不同数量的CPU周期来计算。因此，我们引入了一个复杂性因子ai来衡量计算MU i任务的每比特所需的CPU周期数。卸载的计算任务部分可以表示为hi &#x3D; {li, bi, tmax i }，<strong>其中li是卸载到ESP的部分任务的大小，bi是卸载部分任务所需的CPU周期数。</strong> 同样，tmax i 表示卸载部分任务的时间约束。因此，基于复杂性因子ai，我们可以得到bi &#x3D; ai · li，其中li ∈ [0, Li]且bi ∈ [0, Bi]。为了便于阅读，使用的符号及其相应解释列在表I中。</p>
<p><strong>A. 通信模型</strong></p>
<p>在该场景中，如果MU i决定将其任务卸载到BS-MEC服务器，传输速率表示为RB i ，如果MU i决定将其任务卸载到UAV-MEC服务器，传输速率表示为RU i 。因此，RB i 可以定义为：<br>$$ RB i &#x3D; WB \log_2 \left(1 + \frac{PiGB i}{N0}\right) $$<br>其中WB是MU i和BS-MEC服务器之间的信道带宽，Pi是MU i的传输功率；N0是背景噪声功率；GB i &#x3D; μ0(gB i )τ是MU i和BS-MEC服务器之间的信道增益，其中μ0是衰落分量，τ是信道路径损耗指数，gB i 是MU i和BS-MEC服务器之间的距离。相应地，RU i 可以定义为：<br>$$ RU i &#x3D; WU \log_2 \left(1 + \frac{PiGU i}{N0}\right) $$<br>其中WU是MU i和UAV-MEC服务器之间的信道带宽，$GU i &#x3D; μ0(gU i )τ$ 是MU i和UAV-MEC服务器之间的信道增益，gU i 是MU i和UAV-MEC服务器之间的距离。</p>
<p><strong>B. 计算模型</strong></p>
<p><strong>ESP将为BS-MEC服务器或UAV-MEC服务器分配计算任务</strong>。对于每个卸载的任务hi，我们使用<strong>xi，xi ∈ [0, 1]来表示分配给BS-MEC服务器的比例，因此1 − xi表示分配给UAV-MEC服务器的比例。</strong> <strong>xi &#x3D; 0意味着卸载的任务hi不在BS-MEC服务器上计算，xi &#x3D; 1意味着卸载的任务hi全部在BS-MEC服务器上计算</strong>。在本文中，我们假设每个卸载任务hi的比例分配由ESP决定，因此我们不考虑xi的具体值，并将其视为一个常数。</p>
<ol>
<li><p>计算卸载到BS-MEC服务器：基于上述任务模型，根据传输速率RB i，可以从MU i传输任务hi到BS-MEC服务器的时间获得为：<br>$$ t_{tran,B}^i &#x3D; \frac{xili}{RB i} $$<br>BS-MEC服务器分配给MU i的计算资源定义为f B i 。然后，在BS-MEC服务器上的计算时间是卸载任务的计算量除以BS-MEC服务器的计算频率，表示为：<br>$$ t_{com,B}^i &#x3D; \frac{xibi}{f B i} $$<br>根据[42]，发送计算结果到MUs的时间被忽略，因此当hi卸载到BS-MEC服务器时的总执行时间可以表示为：<br>$$ tB i &#x3D; t_{tran,B}^i + t_{com,B}^i &#x3D; \frac{xili}{RB i} + \frac{xibi}{fB i} $$<br>为了计算MU i的能耗，假设MU i使用恒定的传输功率Pi发送数据，因此MU i卸载其计算任务的能耗可以计算为：<br>$$ EB i &#x3D; t_{tran,B}^i Pi &#x3D; \frac{xiliPi}{RB i} $$</p>
</li>
<li><p>计算卸载到UAV-MEC服务器：类似地，基于传输速率RU i，可以从MU i传输hi到UAV-MEC服务器的时间获得为：<br>$$ t_{tran,U}^i &#x3D; \frac{(1 − xi)li}{RU i} $$<br>假设分配给MU i的UAV-MEC服务器的计算资源为fU i 。然后，在UAV-MEC服务器上的计算时间是卸载任务的计算量除以UAV-MEC服务器的计算频率，表示为：<br>$$ t_{com,U}^i &#x3D; \frac{(1 − xi)bi}{fU i} $$<br>然后，当hi卸载到UAV-MEC服务器时的总执行时间很容易表示为：<br>$$ tU i &#x3D; t_{tran,U}^i + t_{com,U}^i &#x3D; \frac{(1 − xi)li}{RU i} + \frac{(1 − xi)bi}{f U i} $$<br>同样，MU i卸载其计算任务的能耗可以计算为：<br>$$ EU i &#x3D; t_{tran,U}^i Pi &#x3D; \frac{(1 − xi)liPi}{RU i} $$</p>
</li>
</ol>
<p><strong>C. MU的模型</strong></p>
<p>对于每个MU，我们使用对数效用函数来表示其卸载计算任务的满足函数，这可以很好地反映MU和满足之间的关系[43]，并且可以表示为：<br>$$ Fi &#x3D; ω \ln(1 + li) $$<br><strong>其中ω表示MU的满足因子，li表示卸载到ESP的计算任务的大小</strong>。此外，我们还考虑了<strong>MUs之间的相互影响</strong>。如[45]所示，MUs的效用函数是基于社会外部性模型建立的。值得注意的是，<strong>每个MU的效用不仅与其内在愿望有关，还受到其他MUs的影响</strong>。具体来说，我们使用矩阵SR来表示MUs之间的影响，MUs的矩阵描述如下：<br>$$ SR &#x3D; \begin{bmatrix}<br>r1,1 &amp; r1,2 &amp; \cdots &amp; r1,N \<br>r2,1 &amp; \cdots &amp; r2,N-1 &amp; \cdots &amp; rN-1,2 &amp; \cdots &amp; rN,N<br>\end{bmatrix} $$<br>在矩阵SR中，对于任意两个MUs，<strong>社会关系度表示为ri,j，i, j ∈ {1, 2, …, N}，其中ri,j ∈ [0, 1]。ri,j的值越大，表示MU i和j在社会网络中的关系越密切。</strong> ri,j &#x3D; 1意味着两个MUs i和j具有紧密的社会关系。而ri,j &#x3D; 0意味着两个MUs i和j没有关系。此外，认为MU i和MU j之间的影响是相同的，称为ri,j &#x3D; rj,i，矩阵假定为固定。因此，对于MU i，其他MU对其的总影响表示为：<br>$$ Mi &#x3D; σ \left( \sum_{j&#x3D;1}^{N} ri,jFj \right) Fi $$<br><strong>其中σ是社会外部性强度，Fj是MU j（j ≠ i）的满足函数</strong>。当然，MUs在卸载计算任务时需要向ESP支付一些费用，ESP收取统一费用。因此，MU i向ESP的支付计算为：<br>$$ CE i &#x3D; lidi $$<br><strong>其中di表示MU i向ESP的单位支付</strong>。MU i的效用函数定义为由于计算卸载而增加的效用。因此，MU i的效用函数表示为：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241031234049.png"
                      alt="image.png"
                ></p>
<p>其中Fi表示MU i的满足函数，Mi表示其他MU对MU i的社会关系影响，EU i和EB i表示MU i将其任务卸载到UAV-MEC服务器或BS-MEC服务器的能耗，CE i代表MU i向ESP的支付。</p>
<p><strong>D. ESP的模型</strong></p>
<p>在本节中，将展示ESP的效用。在我们的场景中，ESP由一个BS-MEC服务器和一个UAV-MEC服务器组成。MUs将其计算任务卸载到ESP进行计算，ESP执行卸载的任务，这不可避免地会产生成本。在<strong>BS-MEC</strong>服务器上执行的计算任务的能耗计算为：<br>$$ EB &#x3D; \sum_{i&#x3D;1}^{N} qi xibi $$<br><strong>其中qi是当计算任务在BS-MEC服务器上完成时每CPU周期的能耗</strong>。无人机-MEC服务器处理计算任务的能耗表示为：<br>$$ EU &#x3D; \sum_{i&#x3D;1}^{N} si (1 − xi)bi $$<br><strong>其中si是当计算任务在UAV-MEC服务器上完成时每CPU周期的能耗</strong>。ESP的成本可以建模为两个服务器的能耗，因此，我们可以获取ESP的成本函数为：<br>$$ EE &#x3D; EB + EU &#x3D; \sum_{i&#x3D;1}^{N} qi xibi + \sum_{i&#x3D;1}^{N} si (1 − xi)bi $$<br>根据（13），MU i向ESP的支付是lidi；因此，ESP向所有MUs收取的总费用表示为：<br>$$ CE &#x3D; \sum_{i&#x3D;1}^{N} CE i &#x3D; \sum_{i&#x3D;1}^{N} lidi $$</p>
<p>然后，ESP的效用是其收入减去成本，而收入是来自MUs的支付，成本包括UAV-MEC和BS-MEC服务器的能耗。因此，ESP的效用表示为：<br>$$ UE &#x3D; CE − EE &#x3D; \sum_{i&#x3D;1}^{N} lidi − \sum_{i&#x3D;1}^{N} qi xibi − \sum_{i&#x3D;1}^{N} si (1 − xi)bi $$</p>
<h2 id="Problem-Formulation-And-Analysis"><a href="#Problem-Formulation-And-Analysis" class="headerlink" title="Problem Formulation And Analysis"></a>Problem Formulation And Analysis</h2><p>本节首先介绍优化问题，然后分析问题以及寻找纳什均衡的存在性。</p>
<p><strong>问题表述与分析</strong></p>
<p>本节首先介绍优化问题，然后分析问题以及寻找纳什均衡的存在性。</p>
<p><strong>A. 问题表述</strong></p>
<p>斯塔克伯格博弈将参与者分为领导者和追随者，追随者根据领导者执行的策略选择最优响应。领导者的最优策略与追随者的最优响应相结合，形成斯塔克伯格均衡。因此，斯塔克伯格博弈可以用来模拟ESP和MUs之间的互动。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241031225915.png"
                      alt="image.png"
                ></p>
<p>图2显示了ESP和MUs之间的斯塔克伯格博弈。ESP作为领导者给出其出价策略di，MU i作为追随者决定卸载的任务hi的大小，并用li表示其卸载策略。因此，支付配置和计算任务卸载配置分别表示为d &#x3D; (d1, d2, …, dN)和l &#x3D; (l1, l2, …, lN)。我们的目标是最大化ESP和MUs的效用。然后，斯塔克伯格博弈表示为：<br>$$ \Gamma &#x3D; {(ESP, MUs), (di, li), (UE, Ui)} $$<br><strong>斯塔克伯格博弈表</strong></p>
<table>
<thead>
<tr>
<th>玩家</th>
<th>ESP（领导者）</th>
<th>MU i（追随者）</th>
</tr>
</thead>
<tbody><tr>
<td>策略</td>
<td>出价策略di</td>
<td>卸载策略li</td>
</tr>
<tr>
<td>效益</td>
<td>UE</td>
<td>Ui</td>
</tr>
</tbody></table>
<p>ESP的优化问题表示为：<br>    <strong>问题1：</strong> 最大化UE<br>$$ \text{最大化 } UE $$<br>    受限于：<br>$$ EU &lt; \epsilon （总共的能耗少于阈值）$$<br>$$ d_{\text{min}}^i \leq di \leq d_{\text{max}}^i（定价必须在指定范围内） $$<br>$$ tB_i \leq t_{\text{max}}^i （BS-MEC 耗时必须少于上限）$$<br>$$ tU_i \leq t_{\text{max}}^i （UAC-MEC耗时必须少于上限）$$<br>其中（22）确保UAV-MEC服务器的能耗小于UAV-MEC服务器用于执行计算任务的能量约束ϵ，（23）显示ESP的出价策略在指定范围内，其中dmax i 和dmin i 分别是最大和最小出价策略，（24）和（25）是任务执行时间的延迟约束。</p>
<p>此外，MU i的优化问题表示为：<br>    <strong>问题2：</strong> 最大化Ui<br>$$ \text{最大化 } Ui $$<br>    受限于：<br>$$ 0 \leq li \leq Li （卸载的任务量不能超过原任务大小）$$$$ tB_i \leq t_{\text{max}}^i （同上，耗时不能超过上限）$$$$ tU_i \leq t_{\text{max}}^i （同上，耗时不能超过上限）$$其中（27）显示卸载任务hi的大小应小于任务Hi的大小，（28）是任务执行时间的延迟约束。</p>
<p><strong>B. 博弈问题分析</strong></p>
<p>我们使用<strong>逆向归纳法</strong>来分析所提出的问题。在第一阶段，确定了每个MU的最优卸载决策。在第二阶段，根据所有MUs的决策，我们确定ESP的最优出价策略。首先，证明了所提出博弈问题的纳什均衡的存在性。</p>
<p><strong>定义1：</strong> 在MUs之间存在唯一的纳什均衡策略，其中$l &#x3D; (l_1, l_2, …, l_N)$。在这一点上，存在一个效用函数$Ui(l<em>i, l</em>-i) ≥ Ui(li, l*-i)$，其中$l_i$是其他MUs的最佳策略。当游戏处于NE时，没有人可以通过单方面改变其策略来增加其效用。<br><strong>定理1：</strong> 在考虑固定数量MUs的动态策略下，对于每个MU，其效用函数满足（14）。然后，对于MUs存在一个唯一的纳什均衡点。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241031234049.png"
                      alt="image.png"
                ><br><strong>证明：</strong> 对于MU i，效用函数是Ui，其公式如（29）所示，xi是一个常数。然后，（29）的一阶导数可以计算为：<br>$$ \frac{\partial Ui}{\partial li} &#x3D; \frac{\omega}{1 + li} \left(1 + \sigma \sum_{j&#x3D;1}^{N} ri,jFj \right) - \frac{xiPi}{RB i} - \frac{(1 - xi)Pi}{RU i} - di $$<br>接下来，（29）的二阶导数可以计算为：<br>$$ \frac{\partial^2 Ui}{\partial l^2 i} &#x3D; -\frac{\omega}{(1 + li)^2} \left(1 + \sigma \sum_{j&#x3D;1}^{N} ri,jFj \right) $$<br>由于ω &gt; 0且(1 + li)^2 &gt; 0，效用函数的二阶导数是负的。<strong>可以观察到MU i的效用函数是一个严格凹函数，这证明了纳什均衡的存在。</strong> 因此，定理1得证。一阶导数（30）设为0，我们可以得到：<br>$$ l^* i &#x3D; \frac{\omega Mi}{Zi + di} - 1 $$<br>其中<br>$$ Mi &#x3D; 1 + \sigma \sum_{j&#x3D;1}^{N} ri,jFj $$<br>$$ Zi &#x3D; xiPi&#x2F;RB i + (1 - xi)Pi&#x2F;RU i $$<br>因此，我们可以得到$l<em>i$是MU i关于其卸载计算任务大小的最佳策略 。<br>然后，设置$l</em>i&#x3D;0$和$l*i&#x3D;Li$，我们可以得到ESP的出价阈值为：<br>$$ d_{\text{min}} i &#x3D; \frac{\omega Mi}{1 + Li} - \frac{Zi}{Li} $$<br>$$ d_{\text{max}} i &#x3D; \frac{\omega Mi}{Zi} - 1 $$<br>通常，如果ESP的出价太高，MUs将不会将他们的计算任务卸载到ESP，如果ESP的出价太低，MUs将卸载所有计算任务。</p>
<blockquote>
<p>[!tip]<br>这里初次看可能会比较费解，其实关键之处就是知道用户的效用函数 $U_i$ 对 $l_i$ 的二阶偏导一直是负值就可以了。一方面，这证明了效用函数存在纳什均衡；另一方面，说明一阶偏导是单调递减的，那么一阶导数为0的时候就是取极大值也是最大值的时候。<br>因此，<em><em>将一阶偏导置为0，就能得出一个 $l_i^</em>$<em><em>，那么也可以得出当卸载任务量为 $l_i^</em>$时，可以得到最大效用。 $l_i^</em>$也就是此时的最佳卸载策略。<br>然后是这样，每个用户全部的任务量是Li，如果价格足够低，那用户肯定是直接把全部的任务都给服务器，此时的最佳策略当然就是 $l_i^</em>&#x3D; Li$；如果价格实在太高，那么用户什么任务也不会卸载的，此时的最佳策略当然就是 $l_i^*&#x3D;0$。 <strong>那么分别带入一阶导数为0 的式子</strong>，就可以知道最低定价和最高定价了。<br><strong>这里的公式只是语言的另一种形象化表达</strong></p>
</blockquote>
<p>因此，ESP的最佳策略应该在dmin i和dmax i之间，MU i的最优策略满足：<br>$$ l^* i &#x3D; \begin{cases}<br>Li<br>（Li为全部的任务量）, &amp; \text{if } di \leq d_{\text{min}} i \<br>\frac{\omega Mi}{Zi + di} - 1, &amp; \text{if } d_{\text{min}} i &lt; di &lt; d_{\text{max}} i \<br>0, &amp; \text{if } di \geq d_{\text{max}} i<br>\end{cases} $$</p>
<p>此外，根据（38），当dmin i &lt; di &lt; dmax i时，我们可以得到以下两个方程：<br>$$ \frac{\partial l^* i}{\partial di} &#x3D; -\frac{\omega Mi}{(Zi + di)^2} $$<br>$$ \frac{\partial^2 l^* i}{\partial d^2 i} &#x3D; \frac{2\omega Mi}{(Zi + di)^3} $$<br><strong>一阶导数小于0</strong>，<strong>这意味着ESP提供的出价越高，MU卸载的计算任务的大小就越小。</strong> 此外，二阶导数恒为正。因此，它是一个严格凹函数，在给定的di范围内，导出的策略l*i是最优和唯一的。</p>
<p><strong>定义2：</strong> 如果$UE(d<em>i, l</em>i) &gt; UE(di, l*i)$，则存在MUs和ESP之间的唯一斯塔克伯格均衡。<br><strong>定理2：</strong> 考虑ESP的动态出价策略和固定数量的MUs，对于ESP，其效用函数满足（19）。然后，存在MUs和ESP之间的唯一纳什均衡。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241101131505.png"
                      alt="image.png"
                ></p>
<p><strong>证明：</strong> 将xi视为常数，并将获得的最佳策略l<em>i代入UE，UE(di, l</em>i)可以得到。ESP的效用函数表示为（41）：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241101131635.png"
                      alt="image.png"
                ></p>
<p>因此$UE(di, l*i)$对di ( <strong>这里的di单指某一个用户</strong> ) 的一阶偏导数计算为（42）：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241101131645.png"
                      alt="image.png"
                ></p>
<blockquote>
<p>[!tip]<br>这里注意，上面的UE是指ESP对全部用户的总收益，下面的这个”$U_E(d_i,l_i^*) 对di$ “计算的是针对某一位用户的收益。因为ESP可以对不同用户采取不同的收费策略</p>
</blockquote>
<p>之后$UE(di, l<em>i)$对di的二阶导数制定为：<br>$$ \frac{\partial^2 UE}{\partial d^2 i} &#x3D; -2aMi \left( Zi + xiqiai + (1 - xi)siai \right) \frac{1}{(Zi + di)^3} $$<br>因为(Zi+di)^3 &gt; 0且$Zi+xiqiai+(1−xi)siai$&gt; 0，很明显ESP效用函数的二阶导数是负的。**可以观察到ESP的效用函数UE(di, l</em>i)是一个严格凹函数，这证明了纳什均衡的存在**。</p>
<p>因此，定理2得证。根据上述定理，证明了斯塔克伯格-纳什均衡在第一阶段和第二阶段都存在且唯一。同样，将（42）的一阶导数设为0，我们可以得到方程：<br>$$ d^* i &#x3D; \sqrt{\omega Mi \left( Zi + xiqiai + (1 − xi)siai \right)} - Zi $$<br>根据最佳策略di应在dmin i和dmax i之间的事实，因此ESP的最优策略如下所示：<br>$$ d^* i &#x3D; \begin{cases}<br>d_{\text{min}} i, &amp; \text{if } di \leq d_{\text{min}} i \<br>\sqrt{\omega Mi \left( Zi + xiqiai + (1 − xi)siai \right)} - Zi, &amp; \text{if } d_{\text{min}} i &lt; di &lt; d_{\text{max}} i \<br>d_{\text{max}} i, &amp; \text{if } di \geq d_{\text{max}} i<br>\end{cases} $$</p>
<blockquote>
<p>[!note]<br>这一部分的原理同上，就是证明出商家ESP的收益函数也是一个严格凹函数（二阶导数始终保持负值），那么也就说明ESP的效益函数存在纳什均衡。 和上面一样，一阶导数为0时能够取得最大收益，此时能够得到最佳定价 $d_i^*$。</p>
</blockquote>
<h2 id="Gradient-Based-Dynamic-Iterative-Search-Algorithm"><a href="#Gradient-Based-Dynamic-Iterative-Search-Algorithm" class="headerlink" title="Gradient-Based Dynamic Iterative Search Algorithm"></a>Gradient-Based Dynamic Iterative Search Algorithm</h2><p><strong>V. 基于梯度的动态迭代搜索算法</strong></p>
<p>本节提出了GDISA来获得唯一的纳什和斯塔克伯格均衡。</p>
<p>算法1展示了GDISA的细节。首先，我们设置了迭代次数m &#x3D; 0和n &#x3D; 0的初始值。然后，ESP在dmin i和dmax i之间设置了初始出价策略d(0)，这些可以通过（36）和（37）计算得出，所有MUs设置了初始卸载策略l(0)在0和Li之间。</p>
<p>在收到初始d(0)和l(0)后，ESP根据d(m + 1) &#x3D; d(m) + θ∇UE(d(m), l*(d(m)))计算其新的出价策略，<em><em>其中∇UE(d(m), l</em>(d(m)))是基于（42）和（45）的梯度([∂UE(m)]&#x2F;[∂di(m)]), θ是步长</em><em>。此时，每个MU i根据l(n + 1) &#x3D; l(n) + θ∇Ui(l(n), l</em>(l(n)))计算其新的卸载策略，<em><em>其中∇Ui(l(n), l</em>(l(n)))是基于（32）和（38）的梯度([∂Ui(n)]&#x2F;[∂li(n)]), θ是步长。</em>* 然后，设置n+1 &#x3D; n和m+1 &#x3D; m，ESP和MUs将继续迭代寻找更好的策略以最大化他们的效用。</p>
<p>直到([∥ln+1 − ln∥1]&#x2F;[∥ln∥1]) ≤ ξ，MUs将停止重复，迭代结束，其中ξ是精度阈值，∥y∥1表示y的一阶范数。同样，ESP将在([∥dm+1 − dm∥1]&#x2F;[∥dm∥1]) ≤ ξ时停止重复。此时，可以获得ESP和MUs策略的近似最优解，分别表示为d<em>和l</em>。因此，获得了ESP和MUs的最优效用。</p>
<p><strong>算法1 GDISA</strong><br>输入：MUs N，任务Hi，以及其他参数；<br>输出：最佳出价策略d<em>，最佳卸载策略l</em>，U<em>i，U</em>E；<br>1: 初始化：m &#x3D; 0, n &#x3D; 0, 精度阈值ξ，步长θ；<br>2: 设置d(m) &#x3D; (d1(m), d2(m), …, dN(m))，其中dmin i &lt; di(m) &lt; dmax i；<br>3: ESP使用梯度上升搜索算法找到最佳出价集，其中d(m + 1) &#x3D; d(m) + θ∇UE(d(m), l*(d(m)))；<br>4: 设置l(n) &#x3D; (l1(n), l2(n), …, lN(n))，其中0 &lt; li(n) &lt; Li；<br>5: 每个MU i使用梯度上升搜索算法找到最佳卸载集，其中l(n + 1) &#x3D; l(n) + θ∇Ui(l(n), l*(l(n)))；<br>6: while $\frac{∥dm+1−dm∥1} {∥dm∥1}$ ≥ ξ do<br>7: 对于每次迭代m<br>8: 重复步骤（2）和步骤（3）；<br>9: while $\frac{∥ln+1−ln∥1}{∥ln∥1}$ ≥ ξ do<br>10: 对于每次迭代n<br>11: 重复步骤（4）和步骤（5）；<br>12: n ← n + 1；<br>13: end while<br>14: m ← m + 1；<br>15: end while<br>16: 获得最优d<em>和l</em>；<br>17: 根据方程（19）计算U<em>E，根据方程（14）计算U</em>i；<br>18: 返回U<em>i，U</em>E</p>
<blockquote>
<p>[!note]<br>这里就是普通的梯度下降算法，初始的(l1,l2,l3,…)还有(d1,d2,d3,…)都是随机的</p>
</blockquote>
<h2 id="SIMULATION-RESULTS"><a href="#SIMULATION-RESULTS" class="headerlink" title="SIMULATION RESULTS"></a>SIMULATION RESULTS</h2><p><strong>VI. 模拟结果</strong></p>
<p>本节进行模拟以评估GDISA的收敛性能和有效性。特别是，将GDISA与其他基准方法进行比较，并研究了一些参数对ESP和MUs效用的影响。</p>
<p><strong>A. 参数设置</strong></p>
<p>在模拟中，多个MUs随机分布在ESP的覆盖范围内。MUs的数量设置在[5, 30]的范围内。MUs生成的任务大小在10M到20M之间，任务的容忍延迟在[0.05秒，3秒]的范围内。我们设置了BS-MEC和UAV-MEC服务器的单位能耗在[0.2, 1.7]（焦耳&#x2F;兆次循环）的范围内。满意度因子度为5，复杂度因子在[0.1, 5]的范围内。BS-MEC服务器的计算频率为50 GHz，UAV-MEC服务器的计算频率为10 GHz。表II给出了使用的主参数。此外，我们提供了以下四种基准方法进行性能比较：</p>
<ol>
<li>随机（RANDOM）：ESP的出价和MUs的卸载策略都是随机生成的。</li>
<li>全部卸载（FO）：所有MUs的任务都卸载到ESP，然后ESP根据我们提出的GDISA确定其最优策略。</li>
<li><strong>无UAV-MEC服务器（NU</strong>）：类似于[44]，系统中没有UAV-MEC服务器，只有一个BS-MEC服务器为MUs提供计算服务。</li>
<li><strong>ESP和MU之间的非合作博弈</strong>（NG）：NG没有考虑其他MUs的影响，因此只有MUs之间的竞争，<strong>每个MU独立与ESP互动以找到自己的最优决策，而不考虑其他MUs的政策</strong>。这是一个非合作博弈，每个MU与ESP之间[45]。</li>
</ol>
<p><strong>B. 收敛性能</strong></p>
<p>图3显示了所有MUs和ESP效用的迭代过程。最初设置MUs的数量为5。如图3所示，ESP和MUs的效用逐渐增加，并最终收敛和稳定。此外，ESP的效用在开始时相对较高，随着迭代次数的增加而迅速增加。大约100次迭代后，它稳定并接近最优解。可以发现，MUs的平均效用也从比较高的值开始。然而，与ESP的效用相比，MUs的平均效用没有很快达到稳定状态。这是由于MUs之间的非合作关系，它们相互竞争以最大化自己的效用。最终，获得了ESP和MUs的效用以及相应的最优解。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241101143606.png"
                      alt="image.png"
                ></p>
<p><strong>C. 参数影响</strong></p>
<p>这部分评估了BS-MEC服务器和UAV-MEC服务器单位能耗对ESP效用的影响。如图4所示，我们将两个服务器的单位能耗设置在[0.2, 1.7]的范围内。随着单位能耗的增加，ESP的效用减少，它们之间的关系是线性且成反比的。这是因为单位能耗的增加，相应地，ESP执行计算任务的成本变得更高，这不可避免地降低了ESP的效用。此外，当单位能耗保持不变且MUs数量增加时，ESP的效用增加。主要原因是随着MUs数量的增加，更多的MUs参与任务卸载过程，ESP可以通过出售更多的计算资源来增加其效用。根据我们的模型，ESP可以通过参与计算卸载来增加其效用。此外，由于单位能耗与决策和MUs的效用无关，我们不评估其对MUs效用的影响。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241101143623.png"
                      alt="image.png"
                ></p>
<p><strong>D. 性能比较</strong></p>
<p>这部分比较了GDISA与其他四种基准方法在不同场景下的性能。首先，我们比较了在不同MUs数量下ESP和MUs的效用。图5和图6分别展示了在不同MUs数量下GDISA与其他基准方法的性能比较。图5显示了MUs平均效用的性能比较，图6显示了ESP效用的性能比较。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241101143825.png"
                      alt="image.png"
                ></p>
<p>可以看到，在不同MUs数量下，GDISA的表现最佳。此外，其他三种方法随着MUs数量的逐渐增加，表现出与GDISA相同的趋势。具体来说，我们可以观察到NU的效用最低。这是因为如果ESP只包括BS-MEC服务器，它将承受更大的计算压力，无法进行许多MUs的任务。MUs无法通过计算卸载来增加他们的效用，ESP也无法通过出售更多的计算资源来提高其效用。因此，在NU情况下，MUs和ESP的效用都较低。此外，MUs和ESP的效用在FO情况下相对较高，接近GDISA。这表明当所有MUs的计算任务都卸载时，MUs和ESP的效用接近他们的最优效用。相应地，在随机情况下，ESP和MUs的效用高于NU且低于FO。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241101143840.png"
                      alt="image.png"
                ></p>
<p>由于NG没有考虑其他MUs的影响，其在MUs平均效用方面的性能显著低于我们提出的GDISA。这表明MUs之间的社会关系在卸载决策中起着至关重要的作用，每个MU独立获取最优策略无法带来更好的整体平均效用。与MUs的平均效用相比，NG在ESP效用方面表现更好。在NG情况下，ESP仍然可以通过出售计算资源获得相对较高的效用。总的来说，可以发现UAV-MEC服务器和MUs的社会关系对不同方法的性能有重要影响。</p>
<p>图7显示了在不同单位能耗qi下ESP效用的比较。同样，对于ESP，GDISA具有最高的效用。在其他四种基准方案中，NG的效用更高，NU的效用更低。此外，随着单位能耗qi的增加，ESP的效用减少，这已经在图4中详细描述。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241101143852.png"
                      alt="image.png"
                ></p>
<p>总之，我们证明了GDISA不仅可以提高MUs和ESP的效用，而且可以获得唯一的均衡。因此，GDISA在不同场景中被证明是有效的。</p>
<p><strong>VII. 讨论和未来工作</strong></p>
<p>本节讨论了潜在的和有吸引力的未来工作。</p>
<p><strong>A. 无人机辅助和基于区块链的计算卸载</strong></p>
<p>区块链已经吸引了广泛的关注，并在各种应用领域中得到广泛应用，特别是在与边缘计算结合时。由于我们提出的无人机辅助计算卸载中没有考虑安全交易问题，将区块链与我们提出的模型结合起来是有效的。在区块链赋能和无人机辅助的计算卸载中，MUs在向ESP支付相应费用后，可以将他们的计算任务卸载到BS-MEC服务器或UAV-MEC服务器，所有交易数据都记录在区块链上，以建立信任和保护隐私。我们可以引入智能合约技术，这是一种可靠的市场监督解决方案，因为它部署在区块链上，无法被篡改。通过区块链的去中心化、安全性和可追溯性，智能合约使MUs能够保持信息透明度并与ESP建立信任，从而确保MUs支付的可靠性，并禁止恶意支付和其他非法行为。在未来，我们将考虑使用区块链赋能和无人机辅助的计算卸载中的智能合约来解决优化问题。</p>
<p><strong>B. 无人机辅助和基于深度强化学习的计算卸载</strong></p>
<p>最近，各种人工智能（AI）方法，如深度强化学习（DRL），已被用于解决MEC中的优化问题。一方面，通过结合DRL，计算从远程云推向网络边缘，以实现各种实时和可靠的智能服务。另一方面，DRL也有潜力解决各种网络优化问题（例如，卸载决策和资源分配）。</p>
<p>我们目前的研究重点是提高静态系统的性能，而没有考虑动态时变环境。为了解决时变系统中的复杂优化问题，DRL方法更适合获得最佳决策策略并最大化长期奖励。在未来的工作中，我们将考虑使用DRL来解决动态时变环境中的优化问题。</p>
<p><strong>VIII. 结论</strong></p>
<p>本文研究了一个由一个UAV-MEC服务器、一个BS-MEC服务器和多个MUs组成的无人机辅助MEC网络。为了最大化ESP和MUs的效用，ESP和MUs之间的互动被建模为斯塔克伯格博弈，使用逆向归纳法分析了我们提出的博弈问题。证明了所提出的博弈可以达到唯一的纳什均衡，然后提出了GDISA来获得近似最优解。模拟结果表明，GDISA可以有效地激发ESP和MUs之间的合作，并且在不同场景下的表现优于其他基线方法。</p>
]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>Stackelberg</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>Rich Human Feedback for Text-to-Image Generation</title>
    <url>/sni2v6/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>最近文本到图像（T2I）生成模型，如<strong>Stable Diffusion</strong>和<strong>Imagen</strong>，在基于文本描述生成高分辨率图像方面取得了显著进展。然而，许多生成的图像仍然存在诸如伪影&#x2F;不切实际、与文本描述不一致以及低审美质量等问题。受到<strong>人类反馈强化学习（RLHF）在大型语言模型中成功的启发</strong>，先前的工作收集了人类对生成图像的评分作为反馈，并训练了一个奖励模型来改进 T2I 生成。在本文中，我们通过（i）标记图像中不切实际或与文本不一致的区域，以及（ii）注释文本提示中在图像中未被正确表示或缺失的词汇，来丰富反馈信号。我们在 18K 生成图像上收集了这样的丰富人类反馈（RichHF18K），并训练了一个多模态变换器来自动预测丰富的反馈。我们展示了预测的丰富人类反馈如何被用来改进图像生成，例如，通过<strong>选择高质量的训练数据进行微调</strong>以改进生成模型，或者通过<strong>创建带有预测热图的掩码来修复问题区域</strong>。值得注意的是，这些改进推广到了超出我们收集人类反馈数据所用模型（(Stable Diffusion variants）之外的模型（如<strong>Muse</strong>）。RichHF-18K 数据集将在我们的 GitHub 仓库中发布。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>文本到图像（T2I）生成模型[12, 17, 41, 42, 56, 58, 59]正在迅速成为娱乐、艺术、设计和广告等多个领域内容创造的关键，并正在被推广到图像编辑[4, 27, 44, 50]、视频生成[23, 35, 53]等许多其他应用。尽管最近取得了显著进展，输出仍然通常存在诸如<strong>伪影&#x2F;不切实际、与文本描述不一致以及低审美质量</strong>等问题[30, 52, 54]。例如，在主要由 Stable Diffusion variants 生成的<strong>Pick-a-Pic 数据集</strong>中，许多图像（例如图 1）包含扭曲的人&#x2F;动物身体（例如，有超过五个手指的人类手）、扭曲的物体和不切实际的问题，例如漂浮的灯。我们人类评估实验发现，数据集中只有大约 10%的生成图像没有伪影和不切实际的问题。同样，文本-图像不一致问题也很常见，例如，提示是“一个男人跳进河里”，但生成的图像显示男人站着。</p>
<p>然而，现有的自动<strong>评估生成图像的指标</strong>，包括众所周知的<strong>IS</strong>[43]和<strong>FID</strong>[20]，是计算在图像分布上的，可能无法反映单个图像的细微差别。最近的研究收集了人类偏好&#x2F;评级来评估生成图像的质量，并训练了评估模型来预测这些评级[30, 52, 54]，特别是<strong>ImageReward</strong>[54]或<strong>Pick-a-Pic</strong>[30]。虽然更专注，但这些指标仍然将一张图像的质量总结为一个单一的数值评分。在<strong>提示-图像对齐</strong>方面，也有像<strong>CLIPScore</strong>[19]这样的开创性单分数指标，以及最近的问答流程[8, 10, 24, 57]。虽然更加校准和可解释，但这些模型复杂且计算成本高，仍然无法定位图像中的不一致区域。</p>
<p>在本文中，我们提出了一个数据集和模型，用于细粒度的多方面评估，这些评估是可解释和可归因的（例如，归因于图像中的伪影&#x2F;不切实际区域或图像-文本不一致）。作为第一项贡献，我们收集了一个包含丰富人类反馈的 18K 图像数据集（RichHF-18K），其中包含（i）突出显示图像中不切实际&#x2F;伪影和文本-图像不一致的点注释；（ii）标记在提示中指定生成图像中缺失或错误表示的概念的词汇；以及（iii）用于图像合理性、文本-图像对齐、审美和整体评分的四种细粒度评分。有了 RichHF-18K，我们设计了一个多模态变换器模型，我们称之为 Rich Automatic Human Feedback（RAHF），以学习预测生成图像及其相关文本提示上的这些丰富的人类注释。因此，我们的模型可以预测不切实际和不一致的区域、不一致的关键词，以及细粒度的评分。这不仅提供了可靠的评级，还提供了关于生成图像质量的更详细和可解释的见解。据我们所知，这是第一个丰富的反馈数据集和模型，用于最新的文本到图像生成模型，提供了一个自动和可解释的流程来评估 T2I 生成。</p>
<p>主要贡献总结如下：</p>
<ol>
<li><strong>第一个丰富的人类反馈数据集（RichHF-18K）</strong> 在生成图像上（包括细粒度评分、不切实际（伪影）&#x2F;不一致的图像区域和不一致的关键词），在 18K Pick-a-Pic 图像上。</li>
<li><strong>一个多模态变换器模型（RAHF）</strong>，用于<strong>预测生成图像上的丰富反馈</strong>，我们展示了它与测试集上的人类注释高度相关。</li>
<li>我们进一步展示了 RAHF 预测的丰富人类反馈对改进图像生成的有用性：（i）使用预测的热图作为掩码来修复问题图像区域，以及（ii）使用预测的评分来帮助微调图像生成模型（如 Muse[6]），例如，通过选择&#x2F;过滤微调数据，或作为奖励指导。在这两种情况下，我们都获得了比原始模型更好的图像。</li>
<li>在 Muse 模型上的改进，该模型与用于生成训练集中图像的模型不同，显示了我们的 RAHF 模型的良好泛化能力。</li>
</ol>
<h2 id="2-Related-Works"><a href="#2-Related-Works" class="headerlink" title="2. Related Works"></a>2. Related Works</h2><p><strong>Text-to-image generation</strong><br>文本到图像（T2I）生成模型在深度学习时代经历了几个流行的模型架构的演变和迭代。早期的工作是生成对抗网络（<strong>GAN</strong>）[3, 16, 26]，它训练一个生成器进行<strong>图像生成和一个鉴别器</strong>来区分真实和生成的图像（也见[32, 38, 47, 55, 60, 62]等）。另一类生成模型发展<strong>自变分自编码器</strong>（VAEs）[21, 29, 48]，它们优化证据下界（ELBO）以获得图像数据的可能性。<br>最近，<strong>扩散模型（DMs）</strong>[22, 36, 41, 46]作为图像生成的最新技术（SOTA）出现[13]。DMs 被训练以<strong>从随机噪声中逐步生成图像，与 GANs 相比能够捕捉更多的多样性，并实现良好的样本质量</strong>[13]。Latent Diffusion Models[41]是进一步的改进，它在紧凑的潜在空间中执行扩散过程，以提高效率。</p>
<p><strong>文本到图像评估和奖励模型</strong><br>最近有很多工作在多个维度上评估文本到图像模型[9, 25, 30, 31, 37, 51, 52, 54]。Xu 等人[54]通过要求用户对多个图像进行排名并根据其质量进行评分，收集了人类偏好数据集。他们训练了一个<strong>奖励模型 ImageReward</strong>用于人类偏好学习，并提出了<strong>奖励反馈学习（ReFL）</strong> 以使用 ImageReward 模型调整扩散模型。Kirstain 等人[30]构建了一个网络应用，通过要求用户从一对生成的图像中选择更好的图像，收集了超过 500K 个由 T2I 模型（如 Stable Diffusion 2.1, Dreamlike Photoreal 2.05 和 Stable Diffusion XL 变体）生成的 Pick-a-Pic 数据集。他们利用人类偏好数据集训练了一个基于 CLIP[39]的评分函数，称为 PickScore，以预测人类偏好。Huang 等人[25]提出了一个名为 T2I-CompBench 的基准，用于评估文本到图像模型，包括描述属性绑定、对象关系和复杂构图的 6,000 个文本提示。他们利用多个预训练的视觉语言模型，如 CLIP[39]和 BLIP[34]，计算多个评估指标。Wu 等人[51, 52]收集了大规模的人类对生成图像的选择数据集，并利用该数据集训练了一个输出人类偏好分数（HPS）的分类器。他们展示了通过使用 HPS 调整 Stable Diffusion 来改进图像生成。最近，Lee[31]提出了一个全面的评估 T2I 模型的多细粒度指标。</p>
<p>尽管这些贡献很有价值，但大多数现有工作只使用二元人类评级或偏好排名来构建反馈&#x2F;奖励，并且缺乏提供详细可操作反馈的能力，例如图像中的不切实际区域、不一致区域或不一致关键词。与我们的工作相关的一篇最近的论文是 Zhang 等人[61]，他们收集了图像合成任务的伪影区域数据集，训练了一个基于分割的模型来预测伪影区域，并提出了一种针对这些区域的区域修复方法。然而，他们的工作重点是伪影区域，而本文我们收集了包含不仅是伪影区域，还包括不一致区域、不一致关键词和多个方面的四种细粒度评分的 T2I 生成的丰富反馈。据我们所知，这是第一项关于文本到图像模型的异构丰富人类反馈的工作。</p>
<h2 id="3-Collecting-rich-human-feedback"><a href="#3-Collecting-rich-human-feedback" class="headerlink" title="3. Collecting rich human feedback"></a>3. Collecting rich human feedback</h2><p><strong>3.1 数据收集过程</strong></p>
<p>在本节中，我们讨论了我们收集 RichHF-18K 数据集的过程，该数据集包括两个热图（伪影&#x2F;不切实际和不一致）、四种细粒度评分（合理性、对齐、审美和总体评分）以及一个文本序列（不一致关键词）。对于每个生成的图像，首先要求注释者检查图像并阅读用于生成它的文本提示。然后，他们标记图像上的点以指示任何不切实际&#x2F;伪影或与文本提示不一致的位置。注释者被告知每个标记点都有一个“有效半径”（图像高度的 1&#x2F;20），这形成了以标记点为中心的想象圆盘。通过这种方式，我们可以使用相对较少的点来覆盖图像中有缺陷的区域。最后，注释者在 5 点李克特量表上分别为合理性、图像-文本对齐、审美和整体质量标记不一致关键词和四种评分。图像不切实际&#x2F;伪影和不一致的详细定义可以在补充材料中找到。我们设计了一个网络 UI，如图 1 所示，以促进数据收集。关于数据收集过程的更多细节可以在补充材料中找到。</p>
<p><strong>3.2 人类反馈整合</strong></p>
<p>为了提高收集到的人类反馈在生成图像上的可靠性，每个图像-文本对由三个注释者注释。因此，我们需要整合每个样本的多个注释。对于评分，我们简单地平均多个注释者的评分以获得最终评分。对于不一致关键词注释，我们执行多数投票以获得最终的对齐&#x2F;不一致指标序列，使用关键词的最频繁标签。对于点注释，我们首先将它们转换为每个注释的热图，其中每个点被转换为热图上的圆盘区域（如上一子节中讨论的），然后我们计算跨注释者的平均热图。明显不切实际的区域可能会被所有注释者注释，并在最终平均热图上具有高值。</p>
<p><strong>3.3 RichHF-18K: 一个丰富人类反馈的数据集</strong></p>
<p>我们从 Pick-a-Pic 数据集中选择了一个图像-文本对的子集进行数据注释。尽管我们的方法普遍适用并且适用于任何生成的图像，但我们选择的大多数数据集是照片写实图像，由于其重要性和更广泛的应用。此外，我们还想在图像中拥有平衡的类别。为确保平衡，我们利用 PaLI 视觉问题回答（VQA）模型[7]从 Pick-a-Pic 数据样本中提取一些基本特征。具体来说，我们为 Pick-a-Pic 中的每个图像-文本对提出了以下问题。1）图像是否写实？2）哪个类别最好地描述了图像？在‘人类’、‘动物’、‘对象’、‘室内场景’、‘室外场景’中选择一个。PaLI 对这两个问题的回答通常在我们的手动检查下是可靠的。我们使用这些答案从 Pick-a-Pic 中采样一个多样化的子集，结果得到了 17K 图像-文本对。我们将 17K 样本随机分成两个子集，一个训练集有 16K 样本，一个验证集有 1K 样本。16K 训练样本的属性分布在补充材料中显示。此外，我们收集了 Pick-a-Pic 测试集中独特提示及其对应图像的丰富人类反馈作为我们的测试集。总共，我们收集了来自 Pick-a-Pic 的 18K 图像-文本对的丰富人类反馈。我们的 RichHF18K 数据集包括 16K 训练、1K 验证和 1K 测试样本。</p>
<p><strong>3.4 RichHF-18K 的数据统计</strong></p>
<p>在本节中，我们总结了评分的统计数据，并进行了评分的注释者一致性分析。我们使用公式（s-smin）&#x2F;（smax-smin）标准化评分 s，以便评分位于[0,1]范围内（smax&#x3D;5 和 smin&#x3D;1）。评分的直方图如图 2 所示。评分的分布类似于高斯分布，而合理性和文本-图像对齐评分的 1.0 评分比例略高。收集到的评分分布确保我们有合理的负面和正面样本数量，用于训练一个好的奖励模型。为了分析注释者对图像-文本对的评分一致性，我们计算了评分之间的最大差异：maxdiff &#x3D; max(scores) - min(scores)，其中评分是图像-文本对的三个评分标签。我们在图 4 中绘制了 maxdiff 的直方图。我们可以看到，大约 25%的样本具有完美的注释者一致性，大约 85%的样本具有良好的注释者一致性（标准化后 maxdiff 小于或等于 0.25 或 5 点李克特量表中的 1）。</p>
]]></content>
      <categories>
        <category>多模态</category>
      </categories>
      <tags>
        <tag>RLHF</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先（LCA)</title>
    <url>/sni2zo/</url>
    <content><![CDATA[<h1 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h1><p>给定一颗无向树，并且给出树中任意两个结点，要求求出这两个节点的最近公共祖先。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241118140205.png"
                      alt="image.png|440" style="zoom: 33%;" 
                ></p>
<h1 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h1><h2 id="1-DFS初始化"><a href="#1-DFS初始化" class="headerlink" title="1.DFS初始化"></a>1.DFS初始化</h2><p>这里直接说解决方法，推荐使用倍增法，原理和跳表(<strong>Skiplist</strong>)大致相似。原理是使用一个数组，<code>father[i][j]</code>，含义是结点i的第 $2^{j}$ 个父节点。</p>
<h3 id="（1）父节点处理"><a href="#（1）父节点处理" class="headerlink" title="（1）父节点处理"></a>（1）父节点处理</h3><p>和跳表类似，其实对于每个节点，我们开个大小为31的<code>father[i][31]</code>一般就够用了，其实使用幂乘运算很显然，$2^j&#x3D;2^{j-1}\times2^{j-1}$，所以对于某个节点a，**a的第$2^j$个父节点等于 {a的第$2^{j-1}$个节点的第$2^{j-1}$个父节点}**。 这句话直接看的话可能不太直观，下面是代码描述：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">31</span>;i++)&#123;</span><br><span class="line"> father[root][i]=father[father[root][i-<span class="number">1</span>]][i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="（2）计算每个节点的深度"><a href="#（2）计算每个节点的深度" class="headerlink" title="（2）计算每个节点的深度"></a>（2）计算每个节点的深度</h3><p>不过只知道每个节点的父节点还不够，如果要求LCA，还需要知道每个节点相对于根节点的深度<code>depth[i]</code>。这个简单，只需要在dfs的时候记录一下就可以了。</p>
<h2 id="2-调整深度寻找LCA"><a href="#2-调整深度寻找LCA" class="headerlink" title="2.调整深度寻找LCA"></a>2.调整深度寻找LCA</h2><h3 id="（1）求解深度差，将两个结点置于同一深度"><a href="#（1）求解深度差，将两个结点置于同一深度" class="headerlink" title="（1）求解深度差，将两个结点置于同一深度"></a>（1）求解深度差，将两个结点置于同一深度</h3><p>这里的做法是首先求出深度差，比如差值为7，那么转成二进制就是<code>00000111</code>,那么对于较深的那个节点a，有以下几条步骤：</p>
<ol>
<li>第一步，走一步，找到a的父节点b；</li>
<li>第二步，走两步，找到b的第$2^1$个父节点c；</li>
<li>第三步，走四步，找到c的第$2^2$个父节点d。<br>这样一来，最终找到的节点d与a的深度差一定是：$1+2+4&#x3D;7$。目标达成。</li>
</ol>
<h3 id="（2）遍历父节点，直到两个结点变成LCA的两个不同儿子"><a href="#（2）遍历父节点，直到两个结点变成LCA的两个不同儿子" class="headerlink" title="（2）遍历父节点，直到两个结点变成LCA的两个不同儿子"></a>（2）遍历父节点，直到两个结点变成LCA的两个不同儿子</h3><p>做完第一步有两种情况，情况1是我们刚好找到了LCA，如下图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241118140205.png"
                      alt="image.png|493" style="zoom: 33%;" 
                ><br>这种情况就非常幸运了，直接返回这个节点就可以了。</p>
<p>不过，情况2更为常见，就是我们找到的x和y其实是深度相同的不同节点。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/004db5ed85c62379cc49ae89e2bb5e9.jpg"
                      alt="004db5ed85c62379cc49ae89e2bb5e9.jpg" style="zoom:33%;" 
                ><br>那么这种情况下，还是需要继续遍历的，<strong>此时的a就是刚才find的那个‘7’</strong>。我们直接从最大的<code>j=30</code>开始遍历，那么因为这个数字很大，所以一开始father[a][30]和father[b][30]一定都是相同的。</p>
<p>不断减小j，如果减小到一定程度,搞好father[a][j]和father[b][j]不相同，那么就可以进一步缩小范围，更新 <code>a=father[a][j]</code>，<code>b=father[b][j]</code>。直接进一步减少j，直到找到最接近LCA的两个不同的a和b。</p>
<blockquote>
<p>[!note]<br>Question:为什么这里第一次找到不同的father[a][j]和father[b][j]时不能break？</p>
</blockquote>
<p>这里非常推荐使用&#x3D;&#x3D;二进制&#x3D;&#x3D;的方式回答这个问题。我们可以回顾求深度差的那个部分，现实中非常有可能出现的情况是，LCA和a的深度差并不是2的整数幂！！！</p>
<p>比如LCA距离a的深度差为23，化成二进制就是<code>10101</code>，如果只跳一次就是16，就是<code>10000</code>，所以还是需要继续寻找更小的j的，这里不能就在第一次的时候就break！！</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOGN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN][LOGN], dep[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> parent)</span> </span>&#123;</span><br><span class="line">    fa[node][<span class="number">0</span>] = parent;</span><br><span class="line">    dep[node] = dep[parent] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; LOGN; i++) &#123;</span><br><span class="line">        fa[node][i] = fa[fa[node][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个节点都连接着自己的父节点，加上此句避免重复访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> child : adj[node]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != parent) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(child, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preprocess</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    dep[root] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 令 y 比 x 深。</span></span><br><span class="line">  <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="comment">// 令 y 和 x 在一个深度。</span></span><br><span class="line">  <span class="type">int</span> tmp = dep[y] - dep[x];</span><br><span class="line">  <span class="comment">// 根据深度差的二进制值选择y的父节点，保证y和x的深度是相同的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; tmp; ++j, tmp &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) y = fa[y][j];</span><br><span class="line">  <span class="comment">// 如果这个时候 y = x，那么 x，y 就都是它们自己的祖先。</span></span><br><span class="line">  <span class="keyword">if</span> (y == x) <span class="keyword">return</span> y;</span><br><span class="line">  <span class="comment">// 不然的话，找到第一个不是它们祖先的两个点。</span></span><br><span class="line">  <span class="comment">// (人话) 也就是找到LCA儿子中的任意两个不同点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">30</span>; j &gt;= <span class="number">0</span> &amp;&amp; y != x; --j) &#123;</span><br><span class="line">    <span class="comment">// 只要是不同点，每次都保存</span></span><br><span class="line">    <span class="keyword">if</span> (fa[x][j] != fa[y][j]) &#123;</span><br><span class="line">      x = fa[x][j];</span><br><span class="line">      y = fa[y][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时x和y已经是LCA中的两个不同节点了，那么它们两的直接父亲一定就是LCA</span></span><br><span class="line">  <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">preprocess</span>(<span class="number">1</span>); <span class="comment">// 假设1是根节点</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lca</span>(u, v) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Leetcode/树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>海战游戏心得</title>
    <url>/sni30q/</url>
    <content><![CDATA[<h2 id="攻击策略"><a href="#攻击策略" class="headerlink" title="攻击策略"></a>攻击策略</h2><h3 id="1-简单贪心策略"><a href="#1-简单贪心策略" class="headerlink" title="1.简单贪心策略"></a>1.简单贪心策略</h3><p>最早的这个攻击策略比较暴力，主要考虑的是如果打中了某个船艇，那么就继续攻击邻近区域，直到将这整艘船艇全部击倒为止。</p>
<h4 id="1-1-策略思想"><a href="#1-1-策略思想" class="headerlink" title="1.1 策略思想"></a>1.1 策略思想</h4><ul>
<li>如果成功击中敌方船艇，那么击中位置的附近位置出现船艇的概率增大；</li>
<li>如果没有成功击中敌方船艇，那么击中位置的附近位置出现船艇的概率减小；</li>
</ul>
<h4 id="1-2-策略实现"><a href="#1-2-策略实现" class="headerlink" title="1.2 策略实现"></a>1.2 策略实现</h4><p>使用一个$10\times10$的权值数组<code>Weight[10][10]</code>，这里的权值就是击中位置出现船艇的概率。我们每次都遍历整个数组，每次都选择权值最大的位置作为击打位置。</p>
<h5 id="初始化-Weight"><a href="#初始化-Weight" class="headerlink" title="初始化 Weight"></a>初始化 Weight</h5><p><code>Weight[10][10]</code>初始化如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241104124920.png"
                      alt="image.png"
                ><br>这样初始化的目的是，<strong>保证在打完全部的初始化位置时，至少能打中一艘长度为 5 的大船艇</strong>。</p>
<h5 id="击中-未击中"><a href="#击中-未击中" class="headerlink" title="击中&#x2F;未击中"></a>击中&#x2F;未击中</h5><p>如果击中，就提升击中位置附近位置的权值。<strong>由于船艇的长度最大为 5，所以就以 5 为范围由近到远递减增加权值。因为刚才的假设中是认为击中位置的附近更容易再次出现船艇，所以离击中位置越近的位置权值就越高。</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/f0b03a3b950e818294565068faed42b.jpg"
                      alt="f0b03a3b950e818294565068faed42b.jpg|424"
                ><br>如果未击中，那么就相应的减去权值。<strong>这里的减权值操作比较暴力，考虑到的条件也不是很多。</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/9e8d4a03532bc59a35503b6e30f8c97.jpg"
                      alt="9e8d4a03532bc59a35503b6e30f8c97.jpg|388"
                ><br>当然每次击中的位置都需要记录，这里标记的做法是直接将击中位置的权值<code>Weight[i][j]-=10000</code>，因为棋盘的大小就只有 $10\times10$，而每次我们都选择的是权值最大的位置，所以这样是可以有效标记已击中位置的。</p>
<h4 id="1-3-策略结果"><a href="#1-3-策略结果" class="headerlink" title="1.3 策略结果"></a>1.3 策略结果</h4><p>这个策略最终取得了不错的胜率，不过策略中对未击中之后的位置选取考虑的不多，我个人感觉能取得这个胜率的原因可能是大家部署的<strong>船艇之间比较接近或者船艇的上下左右几个方向刚好可以直达另一搜船</strong>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241104145908.png"
                      alt="image.png"
                ></p>
<h3 id="2-贪心优化-破坏中心点策略"><a href="#2-贪心优化-破坏中心点策略" class="headerlink" title="2.贪心优化+破坏中心点策略"></a>2.贪心优化+破坏中心点策略</h3><h4 id="2-1-策略思想"><a href="#2-1-策略思想" class="headerlink" title="2.1 策略思想"></a>2.1 策略思想</h4><p>上面这个策略在击中某个位置的时候，会同时改变单位长度为5的所有位置的权值。可是，如果只是想尽快击溃某一条船的全部位置，<strong>其实只需要改变单位为1的位置的权值也能做到</strong>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/967f4887d3a027cd81d90f623f8cb07.jpg"
                      alt="967f4887d3a027cd81d90f623f8cb07.jpg|513"
                ><br>如图所示，击中任意一个位置之后，其上下左右必然存在另一个可击中点（<strong>船艇长度最小也为2</strong>），那么当拥有两个相邻击中点之后，我们就已经可以判定出该船艇摆放的方向，之后只在这个方向的两个端点专门攻击即可。</p>
<p>因为船艇的长度最小为2，所以相邻两个击中点的情况是一定会出现的！这么做不仅可以尽快的击溃某一艘船，同时还可以起到标记效果。<strong>由于我们在判定船艇方向之后只需要对两端点发起攻击，所以只要出现连续两次未击中的情况，就说明有一艘船艇已经被完全击溃了</strong>。</p>
<p>但是这样又会导致另一个问题：<strong>击溃一艘船艇之后又该打哪里？</strong> 刚才的策略中虽然半径为5的权值改变策略比较暴力，但是每次至少都有一个最大权值位置可以打（虽说可能不准）；现在这种做法击溃了一艘船艇之后对这艘船艇周围的权值影响的太少了，很多位置的权值几乎都一样，到底打哪？</p>
<p>这里我想到的策略是<strong>破坏中心点</strong>。在每行每列一定存在很多没有被击打的位置，这里简称之为 <strong>和平区域</strong>。对于每一行每一列的连续和平区，优先攻击中间位置。（类似二分法）</p>
<h4 id="2-2-策略实现"><a href="#2-2-策略实现" class="headerlink" title="2.2 策略实现"></a>2.2 策略实现</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>还是使用一个$10\times10$的矩阵<code>Weight[10][10]</code>记录权值，这里为避免混淆，增加一个<code>stepMemory[10][10]</code>记录未知状态。对于成功命中的位置，<code>stepMemory[i][j]=1</code>；对于未成功命中的位置，<code>stepMemory[i][j]=-1</code>；对于和平区域，<code>stepMemory[i][j]=0</code>。<br>这里如果某位置成功命中，那么只有其距离为1的上下左右四个位置的权值+5；同样的，如果没有命中，也只有其距离为1的上下左右四个位置的权值-5。我们每次依旧选择权值最大的位置。</p>
<h5 id="船艇方向判定"><a href="#船艇方向判定" class="headerlink" title="船艇方向判定"></a>船艇方向判定</h5><p>这里在判定方向的时候增加了一个 <code>wrong_num</code>，刚才说了<strong>只要出现连续两次未击中的情况，就说明有一艘船艇已经被完全击溃了</strong>，所以当有两次连续击中的时候，就将 <code>wrong_num=2</code>。当<code>wrong_num=0</code>时，就可以破坏中心点了。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里如果击中点的四周也有击中点，就可以知道方向了</span></span><br><span class="line">  <span class="comment">// 水平方向</span></span><br><span class="line">  <span class="keyword">if</span>((lastj&gt;<span class="number">0</span>&amp;&amp;fanz_Step_Memory[lasti][lastj<span class="number">-1</span>]==<span class="number">1</span>)||(lastj&lt;<span class="number">10</span>&amp;&amp;fanz_Step_Memory[lasti][lastj<span class="number">+1</span>]==<span class="number">1</span>))&#123;</span><br><span class="line">   wrong_num==<span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span> cur=lastj;</span><br><span class="line">   <span class="keyword">while</span> (cur&gt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span>(fanz_Step_Memory[lasti][cur]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    cur--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(cur&gt;=<span class="number">0</span>) Weight[lasti][cur]+=<span class="number">10</span>;</span><br><span class="line">   cur=lastj;</span><br><span class="line">   <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span>(fanz_Step_Memory[lasti][cur]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    cur++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(cur&lt;<span class="number">10</span>) Weight[lasti][cur]+=<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 竖直方向</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((lasti&gt;<span class="number">0</span>&amp;&amp;fanz_Step_Memory[lasti<span class="number">-1</span>][lastj]==<span class="number">1</span>)||(lasti&lt;<span class="number">10</span>&amp;&amp;fanz_Step_Memory[lasti<span class="number">+1</span>][lastj]==<span class="number">1</span>))&#123;</span><br><span class="line">   wrong_num=<span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span> cur=lasti;</span><br><span class="line">   <span class="keyword">while</span> (cur&gt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span>(fanz_Step_Memory[cur][lastj]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    cur--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(cur&gt;=<span class="number">0</span>) Weight[cur][lastj]+=<span class="number">10</span>;</span><br><span class="line">   cur=lasti;</span><br><span class="line">   <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span>(fanz_Step_Memory[cur][lastj]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    cur++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(cur&lt;<span class="number">10</span>) Weight[cur][lastj]+=<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="破坏中心点实现"><a href="#破坏中心点实现" class="headerlink" title="破坏中心点实现"></a>破坏中心点实现</h5><p>这里使用窗口对每一行每一列的连续和平区域的中心点进行破坏，当<code>wrong_num=0</code>时就执行这段代码。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryCenter</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 打破每行连续安全区域的中间位置</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;start&lt;<span class="number">10</span>;start++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[i][start]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> cur=start;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[i][cur]!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    Weight[i][(start+cur<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>]+=<span class="number">4</span>;</span><br><span class="line">    start=cur;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 打破每列连续安全区域的中间位置</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;start&lt;<span class="number">10</span>;start++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[start][i]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> cur=start;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][i]!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Weight[(start+cur<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>][i]+=<span class="number">4</span>;</span><br><span class="line">    start=cur;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-3-策略结果"><a href="#2-3-策略结果" class="headerlink" title="2.3 策略结果"></a>2.3 策略结果</h4><p>这里测试的环境是Ubuntu，如果每次都把所有playerA和playerB的代码都执行一次需要花费半小时以上，所以这里我测试的时候在 <code>seabattle.py</code>的读取文件方法中限制了自己的学号，这样playerA就只有我一个人，比较省时。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241104155443.png"
                      alt="image.png"
                ></p>
<h5 id="如果不加入”破坏中心点”操作"><a href="#如果不加入”破坏中心点”操作" class="headerlink" title="如果不加入”破坏中心点”操作"></a>如果不加入”破坏中心点”操作</h5><p>这里测试十次，发现了这两种结果。相比于之前的结果，胜率虽然上来了，但是总共战斗的场数却减少了。而且在测试的时候发现存在超时情况。超时原因很可能就是在不破坏中心点的情况下，击败一艘船之后难以定位下一个攻击位置。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Time out: 2024220603019_fanzheng 2024220603008_chenhaojie</span><br><span class="line">Time out: 2024220603019_fanzheng 2024220603042_jinyu</span><br><span class="line">Time out: 2024220603019_fanzheng 2024220603118_zhuokai</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241104110129.png"
                      alt="image.png|451"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241104103345.png"
                      alt="image.png|450"
                ></p>
<h5 id="加入”破坏中心点”操作"><a href="#加入”破坏中心点”操作" class="headerlink" title="加入”破坏中心点”操作"></a>加入”破坏中心点”操作</h5><p>这里也测试10次，结果稳定不变，保持下图结果。这里的胜率相较于上面可能显得低了点，但是总场数增加了，总积分更高，而且执行过程中没有出现超时情况，运行结果也很稳定。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241104105900.png"
                      alt="image.png"
                ></p>
<h2 id="防守策略"><a href="#防守策略" class="headerlink" title="防守策略"></a>防守策略</h2><p>关于防守策略我想的不是很多，最开始我想的摆法是这样的：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241104160947.png"
                      alt="image.png"
                ><br>我最开始的想法是希望五艘船尽可能的处在不同的位置，并且距离尽可能选一些。但是每个人的攻击策略是不一样的，如果有人喜欢先攻击四个对角，那么我会很快损失4艘船。<br>(更新 11&#x2F;05): 改成上述部署方式，使用贪心+破坏中心点策略的结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241105123340.png"
                      alt="image.png"
                ></p>
<p>所以思来想去我也想不到太好的摆法，下图就是我的摆法：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241104161204.png"
                      alt="image.png"
                ></p>
]]></content>
      <categories>
        <category>Bug记录/SeaBattle</category>
      </categories>
      <tags>
        <tag>海战游戏</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title>SeaBattle海战游戏</title>
    <url>/sni31d/</url>
    <content><![CDATA[<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul>
<li>游戏中两个玩家在两块完全相同的棋盘（10x10方格）上进行，两个玩家分别在各自的棋盘上放置他们的舰艇，当然对手是看不见的。</li>
<li>每一个玩家都有5艘舰艇：一艘驱逐舰（2格），一艘潜艇（3格），一艘巡洋舰（3格），一艘战列舰（4格）和一艘航空母舰（5格）。</li>
<li>每艘舰艇都在棋盘上占据一定数量的格子，每艘舰艇既可以横着放，也可以竖着放，但任意两艘舰艇不能互相交叠。</li>
<li>游戏的玩法是双方轮流“轰炸”对方的舰艇，每次轰炸的结果是击中或未击中都会显示，如果击中，该玩家就可以继续攻击，直到击不中为止。</li>
<li>游戏的目标是赶在对手之前把他所有的舰艇都击沉。</li>
</ul>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h2 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h2><blockquote>
<p>common.c 通用函数，打印信息</p>
</blockquote>
<blockquote>
<p>server.c 双方对战主函数。提供上次是否击中信息，轰炸</p>
</blockquote>
<blockquote>
<p>playera.c 玩家A舰艇部署和轰炸策略，需要自己修改，已给出例子</p>
</blockquote>
<blockquote>
<p>playerb.c 玩家B舰艇部署和轰炸策略，需要自己修改，已给出例子</p>
</blockquote>
<h2 id="舰艇说明"><a href="#舰艇说明" class="headerlink" title="舰艇说明"></a>舰艇说明</h2><p>舰艇采用宏定义 见[[common.h]]文件</p>
<p>D为驱逐舰，S为潜艇，C为巡洋舰，B为战列舰，A为航母</p>
<p>部署后可以打印查看，如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DD~~~~~~~~</span><br><span class="line">SSS~~~~~~~</span><br><span class="line">CCC~~~~~~~</span><br><span class="line">BBBB~~~~~~</span><br><span class="line">AAAAA~~~~~</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">~~~~~~~~~~</span><br></pre></td></tr></table></figure></div>

<h3 id="参与者可以任意选择玩家A或玩家B，分别修改playera-c和playerb-c的内容。"><a href="#参与者可以任意选择玩家A或玩家B，分别修改playera-c和playerb-c的内容。" class="headerlink" title="参与者可以任意选择玩家A或玩家B，分别修改playera.c和playerb.c的内容。"></a>参与者可以任意选择玩家A或玩家B，分别修改playera.c和playerb.c的内容。</h3><blockquote>
<p>需要修改的地方：</p>
<blockquote>
<ol>
<li>PlayerAName 或 PlayerBName 改为自己的名字。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ol start="2">
<li>DeploymentA 或 DeploymentB 对舰艇进行部署。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ol start="3">
<li>StrategyA 或 StrategyB 根据服务器提供的信息制定攻击策略，每次只能调用一次开火函数。</li>
</ol>
</blockquote>
</blockquote>
<p><strong>注意：player程序中只能使用server提供的ALastHitB、firetoA之类的函数，可以使用适当的数据结构记录历史的击中信息，但不能出现获取对方部署之类的函数，否则视为作弊，直接判负。</strong></p>
<p>可以有两份策略，也可以使用完全相同的策略。</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>除了player文件其他文件都不用修改。</p>
<p>自己编写好player代码，&#x3D;&#x3D;将所有文件加入到一个VC工程中，编译运行即可&#x3D;&#x3D;。</p>
<p>先在本地调试自己的策略，然后将playera.c和playerb.c上传到自己的文件夹中。</p>
<p>也可以查看其他人的代码，与其他人进行对战。但不要针对其他人的部署进行攻击，因为实际中是不能看到对方部署的，而且要与所有人进行对战，每个人的部署都会不同。</p>
<p><strong>每隔一定时间我会写脚本自动抓取每组的代码进行相互对战，胜率最高组有一定奖励！！！</strong></p>
<h2 id="玩得愉快！"><a href="#玩得愉快！" class="headerlink" title="玩得愉快！"></a>玩得愉快！</h2><p>后续变种：</p>
<ul>
<li>舰艇不能接触</li>
<li>舰艇可对角线排放</li>
<li>未击沉舰艇每回合后可移动（移动距离与其剩余格数一致）</li>
<li>每个玩家都有一发特殊炮弹，可以击打2x2区域或1x4区域。</li>
<li>增加计时功能，策略时间超过一定值直接忽略。</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;player.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initial = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> researchButton = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Informations</span> &#123;</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="type">int</span> hitNum;</span><br><span class="line">  <span class="type">int</span> optionS;</span><br><span class="line">  <span class="type">int</span> optionH;</span><br><span class="line">  <span class="type">int</span> last_Hit_Index[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> found[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125; Information;</span><br><span class="line"></span><br><span class="line">Battlefield PlayerA_BF;</span><br><span class="line"><span class="type">char</span>* PlayerAName = <span class="string">&quot;fanzheng&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="comment">// 玩家部署舰艇</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeploymentA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">      PlayerA_BF.area[i][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">      Weight[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// add your arrangement, for example:</span></span><br><span class="line">  PlayerA_BF.area[<span class="number">0</span>][<span class="number">0</span>] = D;</span><br><span class="line">  PlayerA_BF.area[<span class="number">0</span>][<span class="number">1</span>] = D;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">2</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">3</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">4</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">4</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">5</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">6</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">5</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">6</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">7</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">8</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">2</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">3</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">4</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">5</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">6</span>] = A;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printBF</span>(&amp;PlayerA_BF);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getAttack_Object_Index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>* attack;</span><br><span class="line">  <span class="keyword">return</span> attack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lasti = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lastj = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据上次是否击中确定策略，选择下一个攻击点</span></span><br><span class="line"><span class="comment">// 可以自己创建数据结构记录之前的击中与否信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrategyA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, max;</span><br><span class="line">  <span class="comment">// 从服务器端获取上次攻击是否击中信息</span></span><br><span class="line">  <span class="type">int</span> isHit = <span class="built_in">ALastHitB</span>();</span><br><span class="line">  <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">    Weight[lasti][lastj] -= <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">if</span> (isHit == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 打过的点权值减到底，击中的话给上下左右的点增加权重</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">2</span>][lastj] += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">2</span>][lastj] += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">2</span>] += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">2</span>] += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">3</span>][lastj] += <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">3</span>][lastj] += <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">4</span>][lastj] += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">4</span>][lastj] += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">4</span>] += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">4</span>] += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 打过的点权值减到底，没击中的话给上下左右的点减少权重</span></span><br><span class="line">      Weight[lasti][lastj] -= <span class="number">10000</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">2</span>][lastj] -= <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">2</span>][lastj] -= <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">2</span>] -= <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">2</span>] -= <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">3</span>][lastj] -= <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">3</span>][lastj] -= <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">3</span>] -= <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">3</span>] -= <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">4</span>][lastj] -= <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">4</span>][lastj] -= <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">4</span>] -= <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">4</span>] -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择权重最大的点开火</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">10</span>; l++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; l == <span class="number">0</span>) &#123;</span><br><span class="line">        max = Weight[k][l];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Weight[k][l] &gt; max) &#123;</span><br><span class="line">        max = Weight[k][l];</span><br><span class="line">        i = k;</span><br><span class="line">        j = l;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向(i,j)位置开火</span></span><br><span class="line">  <span class="built_in">firetoB</span>(i, j);</span><br><span class="line">  flag = <span class="number">1</span>;</span><br><span class="line">  lasti = i;</span><br><span class="line">  lastj = j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241030173257.png"
                      alt="image.png"
                ></p>
<p>目前这个算法的缺点在于贪心的范围过广，很多时候没有意义。其实，每次打中之后都应该更关注于离集中点最近的区域，也即击中点的四周。如果某个击中点的四周都没有再次击中，就要考虑换位置了。</p>
<p>但是目前这个算法非常依赖于一次击中，然后再根据击中的区域逐步蔓延，可是这样的话，如果用户放的位置非常稀疏，这样可能会需要遍历整个数组才能找到所有炮弹，</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;player.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initial = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> researchButton = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Informations</span> &#123;</span><br><span class="line"> <span class="comment">/* data */</span></span><br><span class="line"> <span class="type">int</span> hitNum;</span><br><span class="line"> <span class="type">int</span> optionS;</span><br><span class="line"> <span class="type">int</span> optionH;</span><br><span class="line"> <span class="type">int</span> last_Hit_Index[<span class="number">2</span>];</span><br><span class="line"> <span class="type">int</span> found[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">&#125; Information;</span><br><span class="line"></span><br><span class="line">Battlefield PlayerA_BF;</span><br><span class="line"><span class="type">char</span>* PlayerAName = <span class="string">&quot;fanzheng&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fanz_Step_Memory[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家部署舰艇</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeploymentA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">   PlayerA_BF.area[i][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">   Weight[i][j] = <span class="number">0</span>;</span><br><span class="line">   fanz_Step_Memory[i][j]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">4</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">  Weight[<span class="number">4</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">9</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">  Weight[<span class="number">9</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">5</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">  Weight[<span class="number">14</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// add your arrangement, for example:</span></span><br><span class="line"> PlayerA_BF.area[<span class="number">0</span>][<span class="number">0</span>] = D;</span><br><span class="line"> PlayerA_BF.area[<span class="number">0</span>][<span class="number">1</span>] = D;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">2</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">3</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">4</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">4</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">5</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">6</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">5</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">6</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">7</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">8</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">2</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">3</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">4</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">5</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">6</span>] = A;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printBF</span>(&amp;PlayerA_BF);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getAttack_Object_Index</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span>* attack;</span><br><span class="line"> <span class="keyword">return</span> attack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lasti = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lastj = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> clean_num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据上次是否击中确定策略，选择下一个攻击点</span></span><br><span class="line"><span class="comment">// 可以自己创建数据结构记录之前的击中与否信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrategyA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, max;</span><br><span class="line"> <span class="comment">// 从服务器端获取上次攻击是否击中信息</span></span><br><span class="line"> <span class="type">int</span> isHit = <span class="built_in">ALastHitB</span>();</span><br><span class="line"> <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Weight[lasti][lastj] -= 10000;</span></span><br><span class="line">  <span class="keyword">if</span> (isHit == <span class="number">1</span>) &#123;</span><br><span class="line">   fanz_Step_Memory[lasti][lastj]=<span class="number">1</span>;</span><br><span class="line">   <span class="comment">// clean_num=0;</span></span><br><span class="line">   <span class="comment">// 这里如果击中点的四周也有击中点，就可以知道方向了</span></span><br><span class="line">   <span class="comment">// 水平方向</span></span><br><span class="line">   <span class="keyword">if</span>((lastj&gt;<span class="number">0</span>&amp;&amp;fanz_Step_Memory[lasti][lastj<span class="number">-1</span>]==<span class="number">1</span>)||(lastj&lt;<span class="number">10</span>&amp;&amp;fanz_Step_Memory[lasti][lastj<span class="number">+1</span>]==<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="type">int</span> cur=lastj;</span><br><span class="line">    <span class="keyword">while</span> (cur&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[lasti][cur]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">     cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;=<span class="number">0</span>) Weight[lasti][cur]+=<span class="number">10</span>;</span><br><span class="line">    cur=lastj;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[lasti][cur]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&lt;<span class="number">10</span>) Weight[lasti][cur]+=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 竖直方向</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>((lasti&gt;<span class="number">0</span>&amp;&amp;fanz_Step_Memory[lasti<span class="number">-1</span>][lastj]==<span class="number">1</span>)||(lasti&lt;<span class="number">10</span>&amp;&amp;fanz_Step_Memory[lasti<span class="number">+1</span>][lastj]==<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="type">int</span> cur=lasti;</span><br><span class="line">    <span class="keyword">while</span> (cur&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][lastj]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">     cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;=<span class="number">0</span>) Weight[cur][lastj]+=<span class="number">10</span>;</span><br><span class="line">    cur=lasti;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][lastj]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&lt;<span class="number">10</span>) Weight[cur][lastj]+=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 打过的点权值减到底，击中的话给上下左右的点增加权重</span></span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 打过的点权值减到底，没击中的话给上下左右的点减少权重</span></span><br><span class="line">   <span class="comment">// Weight[lasti][lastj] -= 10000;</span></span><br><span class="line">   fanz_Step_Memory[lasti][lastj]=<span class="number">-1</span>;</span><br><span class="line">   <span class="comment">// clean_num++;</span></span><br><span class="line">   <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">   <span class="comment">// if(clean_num&gt;=4)&#123;</span></span><br><span class="line">   <span class="comment">//   destoryCenter();</span></span><br><span class="line">   <span class="comment">//   clean_num=0;</span></span><br><span class="line">   <span class="comment">//  &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 选择权重最大的点开火</span></span><br><span class="line"> max=<span class="number">-200</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">10</span>; l++) &#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[k][l]==<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span> (Weight[k][l] &gt; max) &#123;</span><br><span class="line">    max = Weight[k][l];</span><br><span class="line">    i = k;</span><br><span class="line">    j = l;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 向(i,j)位置开火</span></span><br><span class="line"> <span class="built_in">firetoB</span>(i, j);</span><br><span class="line"> flag = <span class="number">1</span>;</span><br><span class="line"> lasti = i;</span><br><span class="line"> lastj = j;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryCenter</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 打破每行连续安全区域的中间位置</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;start&lt;<span class="number">10</span>;start++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[i][start]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> cur=start;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[i][cur]!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    Weight[i][(start+cur<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>]+=<span class="number">2</span>;</span><br><span class="line">    start=cur;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 打破每列连续安全区域的中间位置</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;start&lt;<span class="number">10</span>;start++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[start][i]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> cur=start;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][i]!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Weight[(start+cur<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>][i]+=<span class="number">2</span>;</span><br><span class="line">    start=cur;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://typora-aliyun01.oss-cn-hangzhou.aliyuncs.com/img/20241031142354.png"
                      alt="image.png"
                ></p>
<p>尝试标记已打结点周围的区域，反而导致胜率大幅下降？</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;player.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initial = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> researchButton = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Informations</span> &#123;</span><br><span class="line"> <span class="comment">/* data */</span></span><br><span class="line"> <span class="type">int</span> hitNum;</span><br><span class="line"> <span class="type">int</span> optionS;</span><br><span class="line"> <span class="type">int</span> optionH;</span><br><span class="line"> <span class="type">int</span> last_Hit_Index[<span class="number">2</span>];</span><br><span class="line"> <span class="type">int</span> found[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">&#125; Information;</span><br><span class="line"></span><br><span class="line">Battlefield PlayerA_BF;</span><br><span class="line"><span class="type">char</span>* PlayerAName = <span class="string">&quot;fanzheng&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fanz_Step_Memory[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家部署舰艇</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeploymentA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">   PlayerA_BF.area[i][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">   Weight[i][j] = <span class="number">0</span>;</span><br><span class="line">   fanz_Step_Memory[i][j]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">4</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">  Weight[<span class="number">4</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">9</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">  Weight[<span class="number">9</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">5</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">  Weight[<span class="number">14</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// add your arrangement, for example:</span></span><br><span class="line"> PlayerA_BF.area[<span class="number">0</span>][<span class="number">0</span>] = D;</span><br><span class="line"> PlayerA_BF.area[<span class="number">0</span>][<span class="number">1</span>] = D;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">2</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">3</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">4</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">4</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">5</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">6</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">5</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">6</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">7</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">8</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">2</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">3</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">4</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">5</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">6</span>] = A;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printBF</span>(&amp;PlayerA_BF);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getAttack_Object_Index</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span>* attack;</span><br><span class="line"> <span class="keyword">return</span> attack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lasti = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lastj = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> small_i=<span class="number">20</span>,big_i=<span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> small_j=<span class="number">20</span>,big_j=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 最多可错次数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> wrong_time=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateSmallAndBig</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">  small_i=<span class="built_in">getmin</span>(small_i,i);</span><br><span class="line">  big_i=<span class="built_in">getmax</span>(big_i,i);</span><br><span class="line">  small_j=<span class="built_in">getmin</span>(small_j,j);</span><br><span class="line">  big_j=<span class="built_in">getmax</span>(big_j,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据上次是否击中确定策略，选择下一个攻击点</span></span><br><span class="line"><span class="comment">// 可以自己创建数据结构记录之前的击中与否信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrategyA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, max;</span><br><span class="line"> <span class="comment">// 从服务器端获取上次攻击是否击中信息</span></span><br><span class="line"> <span class="type">int</span> isHit = <span class="built_in">ALastHitB</span>();</span><br><span class="line"> <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Weight[lasti][lastj] -= 10000;</span></span><br><span class="line">  <span class="keyword">if</span> (isHit == <span class="number">1</span>) &#123;</span><br><span class="line">   fanz_Step_Memory[lasti][lastj]=<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">updateSmallAndBig</span>(lasti,lastj);</span><br><span class="line">   <span class="comment">// 这里如果击中点的四周也有击中点，就可以知道方向了</span></span><br><span class="line">   <span class="comment">// 水平方向</span></span><br><span class="line">   <span class="keyword">if</span>((lastj&gt;<span class="number">0</span>&amp;&amp;fanz_Step_Memory[lasti][lastj<span class="number">-1</span>]==<span class="number">1</span>)||(lastj&lt;<span class="number">10</span>&amp;&amp;fanz_Step_Memory[lasti][lastj<span class="number">+1</span>]==<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="comment">// 两块以上每次正确之后最多可以错两次</span></span><br><span class="line">    wrong_time=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> cur=lastj;</span><br><span class="line">    <span class="keyword">while</span> (cur&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[lasti][cur]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">     cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;=<span class="number">0</span>) Weight[lasti][cur]+=<span class="number">10</span>;</span><br><span class="line">    cur=lastj;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[lasti][cur]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&lt;<span class="number">10</span>) Weight[lasti][cur]+=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 竖直方向</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>((lasti&gt;<span class="number">0</span>&amp;&amp;fanz_Step_Memory[lasti<span class="number">-1</span>][lastj]==<span class="number">1</span>)||(lasti&lt;<span class="number">10</span>&amp;&amp;fanz_Step_Memory[lasti<span class="number">+1</span>][lastj]==<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="comment">// 两块以上每次正确之后最多可以错两次</span></span><br><span class="line">    wrong_time=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> cur=lasti;</span><br><span class="line">    <span class="keyword">while</span> (cur&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][lastj]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">     cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;=<span class="number">0</span>) Weight[cur][lastj]+=<span class="number">10</span>;</span><br><span class="line">    cur=lasti;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][lastj]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&lt;<span class="number">10</span>) Weight[cur][lastj]+=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 打过的点权值减到底，击中的话给上下左右的点增加权重</span></span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 打过的点权值减到底，没击中的话给上下左右的点减少权重</span></span><br><span class="line">   <span class="comment">// Weight[lasti][lastj] -= 10000;</span></span><br><span class="line">   fanz_Step_Memory[lasti][lastj]=<span class="number">-1</span>;</span><br><span class="line">   wrong_time--;</span><br><span class="line">   <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(wrong_time==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//  destoryCenter();</span></span><br><span class="line">     small_i=small_i&lt;=<span class="number">0</span>?<span class="number">0</span>:small_i<span class="number">-1</span>;</span><br><span class="line">     small_j=small_j&lt;=<span class="number">0</span>?<span class="number">0</span>:small_j<span class="number">-1</span>;</span><br><span class="line">     big_i=big_i&gt;=<span class="number">9</span>?<span class="number">9</span>:big_i<span class="number">+1</span>;</span><br><span class="line">     big_j=big_j&gt;=<span class="number">9</span>?<span class="number">9</span>:big_j<span class="number">+1</span>;</span><br><span class="line">      <span class="comment">// 方圆一周的格子都不用遍历了</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> p=small_i;p&lt;=big_i;p++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> q=small_j;q&lt;=big_j;q++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(fanz_Step_Memory[p][q]==<span class="number">0</span>)</span><br><span class="line">            fanz_Step_Memory[p][q]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      small_j=small_j=<span class="number">20</span>;</span><br><span class="line">      big_i=big_j=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 选择权重最大的点开火</span></span><br><span class="line"> max=<span class="number">-200</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">10</span>; l++) &#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[k][l]==<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span> (Weight[k][l] &gt; max) &#123;</span><br><span class="line">    max = Weight[k][l];</span><br><span class="line">    i = k;</span><br><span class="line">    j = l;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 向(i,j)位置开火</span></span><br><span class="line"> <span class="built_in">firetoB</span>(i, j);</span><br><span class="line"> flag = <span class="number">1</span>;</span><br><span class="line"> lasti = i;</span><br><span class="line"> lastj = j;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>保留2之后的权重,但是未命中的时候不减权重，胜率 80%，并没有明显升高</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;player.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initial = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> researchButton = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Informations</span> &#123;</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="type">int</span> hitNum;</span><br><span class="line">  <span class="type">int</span> optionS;</span><br><span class="line">  <span class="type">int</span> optionH;</span><br><span class="line">  <span class="type">int</span> last_Hit_Index[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> found[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">&#125; Information;</span><br><span class="line"></span><br><span class="line">Battlefield PlayerA_BF;</span><br><span class="line"><span class="type">char</span>* PlayerAName = <span class="string">&quot;fanzheng&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fanz_Step_Memory[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家部署舰艇</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeploymentA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">      PlayerA_BF.area[i][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">      Weight[i][j] = <span class="number">0</span>;</span><br><span class="line">      fanz_Step_Memory[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">4</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    Weight[<span class="number">4</span> - j][j] = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">9</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    Weight[<span class="number">9</span> - j][j] = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">5</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    Weight[<span class="number">14</span> - j][j] = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add your arrangement, for example:</span></span><br><span class="line">  PlayerA_BF.area[<span class="number">0</span>][<span class="number">0</span>] = D;</span><br><span class="line">  PlayerA_BF.area[<span class="number">0</span>][<span class="number">1</span>] = D;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">2</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">3</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">4</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">4</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">5</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">6</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">5</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">6</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">7</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">8</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">2</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">3</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">4</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">5</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">6</span>] = A;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printBF</span>(&amp;PlayerA_BF);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getAttack_Object_Index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>* attack;</span><br><span class="line">  <span class="keyword">return</span> attack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lasti = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lastj = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> clean_num = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> small_i = <span class="number">20</span>, big_i = <span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> small_j = <span class="number">20</span>, big_j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"><span class="comment">// 根据上次是否击中确定策略，选择下一个攻击点</span></span><br><span class="line"><span class="comment">// 可以自己创建数据结构记录之前的击中与否信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrategyA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, max;</span><br><span class="line">  <span class="comment">// 从服务器端获取上次攻击是否击中信息</span></span><br><span class="line">  <span class="type">int</span> isHit = <span class="built_in">ALastHitB</span>();</span><br><span class="line">  <span class="keyword">if</span> (isHit == <span class="number">1</span>) &#123;</span><br><span class="line">    fanz_Step_Memory[lasti][lastj] = <span class="number">1</span>;</span><br><span class="line">    clean_num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里如果击中点的四周也有击中点，就可以知道方向了</span></span><br><span class="line">    <span class="comment">// 水平方向</span></span><br><span class="line">    <span class="keyword">if</span> ((lastj &gt; <span class="number">0</span> &amp;&amp; fanz_Step_Memory[lasti][lastj - <span class="number">1</span>] == <span class="number">1</span>) ||</span><br><span class="line">        (lastj &lt; <span class="number">10</span> &amp;&amp; fanz_Step_Memory[lasti][lastj + <span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="type">int</span> cur = lastj;</span><br><span class="line">      <span class="keyword">while</span> (cur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fanz_Step_Memory[lasti][cur] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur &gt;= <span class="number">0</span>) Weight[lasti][cur] += <span class="number">10</span>;</span><br><span class="line">      cur = lastj;</span><br><span class="line">      <span class="keyword">while</span> (cur &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fanz_Step_Memory[lasti][cur] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur &lt; <span class="number">10</span>) Weight[lasti][cur] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 竖直方向</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((lasti &gt; <span class="number">0</span> &amp;&amp; fanz_Step_Memory[lasti - <span class="number">1</span>][lastj] == <span class="number">1</span>) ||</span><br><span class="line">             (lasti &lt; <span class="number">10</span> &amp;&amp; fanz_Step_Memory[lasti + <span class="number">1</span>][lastj] == <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="type">int</span> cur = lasti;</span><br><span class="line">      <span class="keyword">while</span> (cur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fanz_Step_Memory[cur][lastj] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur &gt;= <span class="number">0</span>) Weight[cur][lastj] += <span class="number">10</span>;</span><br><span class="line">      cur = lasti;</span><br><span class="line">      <span class="keyword">while</span> (cur &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fanz_Step_Memory[cur][lastj] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur &lt; <span class="number">10</span>) Weight[cur][lastj] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 打过的点权值减到底，击中的话给上下左右的点增加权重</span></span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">2</span>][lastj] += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">2</span>][lastj] += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">2</span>] += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">2</span>] += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">3</span>][lastj] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">3</span>][lastj] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">4</span>][lastj] += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">4</span>][lastj] += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">4</span>] += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">4</span>] += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 打过的点权值减到底，没击中的话给上下左右的点减少权重</span></span><br><span class="line">    <span class="comment">// Weight[lasti][lastj] -= 10000;</span></span><br><span class="line">    fanz_Step_Memory[lasti][lastj] = <span class="number">-1</span>;</span><br><span class="line">    clean_num++;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择权重最大的点开火</span></span><br><span class="line">  max = <span class="number">-200</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">10</span>; l++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fanz_Step_Memory[k][l] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Weight[k][l] &gt; max) &#123;</span><br><span class="line">          max = Weight[k][l];</span><br><span class="line">          i = k;</span><br><span class="line">          j = l;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向(i,j)位置开火</span></span><br><span class="line">  <span class="built_in">firetoB</span>(i, j);</span><br><span class="line">  flag = <span class="number">1</span>;</span><br><span class="line">  lasti = i;</span><br><span class="line">  lastj = j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 打破每行连续安全区域的中间位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; <span class="number">10</span>; start++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fanz_Step_Memory[i][start] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cur = start;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; <span class="number">10</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fanz_Step_Memory[i][cur] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        Weight[i][(start + cur - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>] += <span class="number">2</span>;</span><br><span class="line">        start = cur;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打破每列连续安全区域的中间位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; <span class="number">10</span>; start++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fanz_Step_Memory[start][i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cur = start;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; <span class="number">10</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fanz_Step_Memory[cur][i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          cur++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Weight[(start + cur - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>][i] += <span class="number">2</span>;</span><br><span class="line">        start = cur;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>保留2之后的权重，未命中的时候也减去权重，胜率83.33%</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;player.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initial = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> researchButton = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Informations</span> &#123;</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="type">int</span> hitNum;</span><br><span class="line">  <span class="type">int</span> optionS;</span><br><span class="line">  <span class="type">int</span> optionH;</span><br><span class="line">  <span class="type">int</span> last_Hit_Index[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> found[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">&#125; Information;</span><br><span class="line"></span><br><span class="line">Battlefield PlayerA_BF;</span><br><span class="line"><span class="type">char</span>* PlayerAName = <span class="string">&quot;fanzheng&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fanz_Step_Memory[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家部署舰艇</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeploymentA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">      PlayerA_BF.area[i][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">      Weight[i][j] = <span class="number">0</span>;</span><br><span class="line">      fanz_Step_Memory[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">4</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    Weight[<span class="number">4</span> - j][j] = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">9</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    Weight[<span class="number">9</span> - j][j] = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">5</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    Weight[<span class="number">14</span> - j][j] = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add your arrangement, for example:</span></span><br><span class="line">  PlayerA_BF.area[<span class="number">0</span>][<span class="number">0</span>] = D;</span><br><span class="line">  PlayerA_BF.area[<span class="number">0</span>][<span class="number">1</span>] = D;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">2</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">3</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">2</span>][<span class="number">4</span>] = S;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">4</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">5</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">4</span>][<span class="number">6</span>] = C;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">5</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">6</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">7</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">6</span>][<span class="number">8</span>] = B;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">2</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">3</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">4</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">5</span>] = A;</span><br><span class="line">  PlayerA_BF.area[<span class="number">8</span>][<span class="number">6</span>] = A;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printBF</span>(&amp;PlayerA_BF);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getAttack_Object_Index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>* attack;</span><br><span class="line">  <span class="keyword">return</span> attack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lasti = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lastj = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> clean_num = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> small_i = <span class="number">20</span>, big_i = <span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> small_j = <span class="number">20</span>, big_j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"><span class="comment">// 根据上次是否击中确定策略，选择下一个攻击点</span></span><br><span class="line"><span class="comment">// 可以自己创建数据结构记录之前的击中与否信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrategyA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, max;</span><br><span class="line">  <span class="comment">// 从服务器端获取上次攻击是否击中信息</span></span><br><span class="line">  <span class="type">int</span> isHit = <span class="built_in">ALastHitB</span>();</span><br><span class="line">  <span class="keyword">if</span> (isHit == <span class="number">1</span>) &#123;</span><br><span class="line">    fanz_Step_Memory[lasti][lastj] = <span class="number">1</span>;</span><br><span class="line">    clean_num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里如果击中点的四周也有击中点，就可以知道方向了</span></span><br><span class="line">    <span class="comment">// 水平方向</span></span><br><span class="line">    <span class="keyword">if</span> ((lastj &gt; <span class="number">0</span> &amp;&amp; fanz_Step_Memory[lasti][lastj - <span class="number">1</span>] == <span class="number">1</span>) ||</span><br><span class="line">        (lastj &lt; <span class="number">10</span> &amp;&amp; fanz_Step_Memory[lasti][lastj + <span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="type">int</span> cur = lastj;</span><br><span class="line">      <span class="keyword">while</span> (cur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fanz_Step_Memory[lasti][cur] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur &gt;= <span class="number">0</span>) Weight[lasti][cur] += <span class="number">10</span>;</span><br><span class="line">      cur = lastj;</span><br><span class="line">      <span class="keyword">while</span> (cur &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fanz_Step_Memory[lasti][cur] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur &lt; <span class="number">10</span>) Weight[lasti][cur] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 竖直方向</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((lasti &gt; <span class="number">0</span> &amp;&amp; fanz_Step_Memory[lasti - <span class="number">1</span>][lastj] == <span class="number">1</span>) ||</span><br><span class="line">             (lasti &lt; <span class="number">10</span> &amp;&amp; fanz_Step_Memory[lasti + <span class="number">1</span>][lastj] == <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="type">int</span> cur = lasti;</span><br><span class="line">      <span class="keyword">while</span> (cur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fanz_Step_Memory[cur][lastj] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur &gt;= <span class="number">0</span>) Weight[cur][lastj] += <span class="number">10</span>;</span><br><span class="line">      cur = lasti;</span><br><span class="line">      <span class="keyword">while</span> (cur &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fanz_Step_Memory[cur][lastj] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur &lt; <span class="number">10</span>) Weight[cur][lastj] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 打过的点权值减到底，击中的话给上下左右的点增加权重</span></span><br><span class="line">      <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">2</span>][lastj] += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">2</span>][lastj] += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">2</span>] += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">2</span>] += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">3</span>][lastj] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">3</span>][lastj] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">4</span>][lastj] += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">4</span>][lastj] += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">4</span>] += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">4</span>] += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 打过的点权值减到底，没击中的话给上下左右的点减少权重</span></span><br><span class="line">    <span class="comment">// Weight[lasti][lastj] -= 10000;</span></span><br><span class="line">    fanz_Step_Memory[lasti][lastj] = <span class="number">-1</span>;</span><br><span class="line">    clean_num++;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">2</span>][lastj] -= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">2</span>][lastj] -= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">2</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">2</span>] -= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">2</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">2</span>] -= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">3</span>][lastj] -= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">3</span>][lastj] -= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">3</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">3</span>] -= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">3</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">3</span>] -= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">4</span>][lastj] -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">4</span>][lastj] -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">4</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">4</span>] -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">4</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">4</span>] -= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择权重最大的点开火</span></span><br><span class="line">  max = <span class="number">-200</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">10</span>; l++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fanz_Step_Memory[k][l] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Weight[k][l] &gt; max) &#123;</span><br><span class="line">          max = Weight[k][l];</span><br><span class="line">          i = k;</span><br><span class="line">          j = l;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向(i,j)位置开火</span></span><br><span class="line">  <span class="built_in">firetoB</span>(i, j);</span><br><span class="line">  flag = <span class="number">1</span>;</span><br><span class="line">  lasti = i;</span><br><span class="line">  lastj = j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 打破每行连续安全区域的中间位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; <span class="number">10</span>; start++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fanz_Step_Memory[i][start] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cur = start;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; <span class="number">10</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fanz_Step_Memory[i][cur] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        Weight[i][(start + cur - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>] += <span class="number">2</span>;</span><br><span class="line">        start = cur;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打破每列连续安全区域的中间位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; <span class="number">10</span>; start++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fanz_Step_Memory[start][i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cur = start;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; <span class="number">10</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fanz_Step_Memory[cur][i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          cur++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Weight[(start + cur - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>][i] += <span class="number">2</span>;</span><br><span class="line">        start = cur;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目前最成功也最稳定的方法，贪心权值+破坏中心区域</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;player.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initial = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> researchButton = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Informations</span> &#123;</span><br><span class="line"> <span class="comment">/* data */</span></span><br><span class="line"> <span class="type">int</span> hitNum;</span><br><span class="line"> <span class="type">int</span> optionS;</span><br><span class="line"> <span class="type">int</span> optionH;</span><br><span class="line"> <span class="type">int</span> last_Hit_Index[<span class="number">2</span>];</span><br><span class="line"> <span class="type">int</span> found[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">&#125; Information;</span><br><span class="line"></span><br><span class="line">Battlefield PlayerA_BF;</span><br><span class="line"><span class="type">char</span>* PlayerAName = <span class="string">&quot;fanzheng&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fanz_Step_Memory[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家部署舰艇</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeploymentA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">   PlayerA_BF.area[i][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">   Weight[i][j] = <span class="number">0</span>;</span><br><span class="line">   fanz_Step_Memory[i][j]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">4</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">  Weight[<span class="number">4</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">9</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">  Weight[<span class="number">9</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">5</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">  Weight[<span class="number">14</span>-j][j]=<span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// add your arrangement, for example:</span></span><br><span class="line"> PlayerA_BF.area[<span class="number">0</span>][<span class="number">0</span>] = D;</span><br><span class="line"> PlayerA_BF.area[<span class="number">0</span>][<span class="number">1</span>] = D;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">2</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">3</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">2</span>][<span class="number">4</span>] = S;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">4</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">5</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">4</span>][<span class="number">6</span>] = C;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">5</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">6</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">7</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">6</span>][<span class="number">8</span>] = B;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">2</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">3</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">4</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">5</span>] = A;</span><br><span class="line"> PlayerA_BF.area[<span class="number">8</span>][<span class="number">6</span>] = A;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printBF</span>(&amp;PlayerA_BF);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getAttack_Object_Index</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span>* attack;</span><br><span class="line"> <span class="keyword">return</span> attack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lasti = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lastj = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Weight[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> wrong_num=<span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据上次是否击中确定策略，选择下一个攻击点</span></span><br><span class="line"><span class="comment">// 可以自己创建数据结构记录之前的击中与否信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrategyA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, max;</span><br><span class="line"> <span class="comment">// 从服务器端获取上次攻击是否击中信息</span></span><br><span class="line"> <span class="type">int</span> isHit = <span class="built_in">ALastHitB</span>();</span><br><span class="line"> <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isHit == <span class="number">1</span>) &#123;</span><br><span class="line">   fanz_Step_Memory[lasti][lastj]=<span class="number">1</span>;</span><br><span class="line">   <span class="comment">// 这里如果击中点的四周也有击中点，就可以知道方向了</span></span><br><span class="line">   <span class="comment">// 水平方向</span></span><br><span class="line">   <span class="keyword">if</span>((lastj&gt;<span class="number">0</span>&amp;&amp;fanz_Step_Memory[lasti][lastj<span class="number">-1</span>]==<span class="number">1</span>)||(lastj&lt;<span class="number">10</span>&amp;&amp;fanz_Step_Memory[lasti][lastj<span class="number">+1</span>]==<span class="number">1</span>))&#123;</span><br><span class="line">    wrong_num==<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> cur=lastj;</span><br><span class="line">    <span class="keyword">while</span> (cur&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[lasti][cur]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">     cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;=<span class="number">0</span>) Weight[lasti][cur]+=<span class="number">10</span>;</span><br><span class="line">    cur=lastj;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[lasti][cur]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&lt;<span class="number">10</span>) Weight[lasti][cur]+=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 竖直方向</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>((lasti&gt;<span class="number">0</span>&amp;&amp;fanz_Step_Memory[lasti<span class="number">-1</span>][lastj]==<span class="number">1</span>)||(lasti&lt;<span class="number">10</span>&amp;&amp;fanz_Step_Memory[lasti<span class="number">+1</span>][lastj]==<span class="number">1</span>))&#123;</span><br><span class="line">    wrong_num=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> cur=lasti;</span><br><span class="line">    <span class="keyword">while</span> (cur&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][lastj]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">     cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;=<span class="number">0</span>) Weight[cur][lastj]+=<span class="number">10</span>;</span><br><span class="line">    cur=lasti;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][lastj]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&lt;<span class="number">10</span>) Weight[cur][lastj]+=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 打过的点权值减到底，击中的话给上下左右的点增加权重</span></span><br><span class="line">    <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] += <span class="number">5</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 打过的点权值减到底，没击中的话给上下左右的点减少权重</span></span><br><span class="line">   fanz_Step_Memory[lasti][lastj]=<span class="number">-1</span>;</span><br><span class="line">   wrong_num--;</span><br><span class="line">   <span class="keyword">if</span> (lasti + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti + <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lasti - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti - <span class="number">1</span>][lastj] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lastj + <span class="number">1</span> &lt; <span class="number">10</span>) Weight[lasti][lastj + <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">if</span> (lastj - <span class="number">1</span> &gt;= <span class="number">0</span>) Weight[lasti][lastj - <span class="number">1</span>] -= <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(wrong_num==<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">destoryCenter</span>();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 选择权重最大的点开火</span></span><br><span class="line"> max=<span class="number">-200</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">10</span>; l++) &#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[k][l]==<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span> (Weight[k][l] &gt; max) &#123;</span><br><span class="line">    max = Weight[k][l];</span><br><span class="line">    i = k;</span><br><span class="line">    j = l;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 向(i,j)位置开火</span></span><br><span class="line"> <span class="built_in">firetoB</span>(i, j);</span><br><span class="line"> flag = <span class="number">1</span>;</span><br><span class="line"> lasti = i;</span><br><span class="line"> lastj = j;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryCenter</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 打破每行连续安全区域的中间位置</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;start&lt;<span class="number">10</span>;start++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[i][start]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> cur=start;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[i][cur]!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    Weight[i][(start+cur<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>]+=<span class="number">4</span>;</span><br><span class="line">    start=cur;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 打破每列连续安全区域的中间位置</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;start&lt;<span class="number">10</span>;start++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(fanz_Step_Memory[start][i]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> cur=start;</span><br><span class="line">    <span class="keyword">while</span> (cur&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(fanz_Step_Memory[cur][i]!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Weight[(start+cur<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>][i]+=<span class="number">4</span>;</span><br><span class="line">    start=cur;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">PlayerA_BF.area[<span class="number">4</span>][<span class="number">4</span>] = D;</span><br><span class="line">PlayerA_BF.area[<span class="number">4</span>][<span class="number">5</span>] = D;</span><br><span class="line">PlayerA_BF.area[<span class="number">9</span>][<span class="number">0</span>] = S;</span><br><span class="line">PlayerA_BF.area[<span class="number">9</span>][<span class="number">1</span>] = S;</span><br><span class="line">PlayerA_BF.area[<span class="number">9</span>][<span class="number">2</span>] = S;</span><br><span class="line">PlayerA_BF.area[<span class="number">0</span>][<span class="number">7</span>] = C;</span><br><span class="line">PlayerA_BF.area[<span class="number">0</span>][<span class="number">8</span>] = C;</span><br><span class="line">PlayerA_BF.area[<span class="number">0</span>][<span class="number">9</span>] = C;</span><br><span class="line">PlayerA_BF.area[<span class="number">0</span>][<span class="number">0</span>] = B;</span><br><span class="line">PlayerA_BF.area[<span class="number">1</span>][<span class="number">0</span>] = B;</span><br><span class="line">PlayerA_BF.area[<span class="number">2</span>][<span class="number">0</span>] = B;</span><br><span class="line">PlayerA_BF.area[<span class="number">3</span>][<span class="number">0</span>] = B;</span><br><span class="line">PlayerA_BF.area[<span class="number">5</span>][<span class="number">9</span>] = A;</span><br><span class="line">PlayerA_BF.area[<span class="number">6</span>][<span class="number">9</span>] = A;</span><br><span class="line">PlayerA_BF.area[<span class="number">7</span>][<span class="number">9</span>] = A;</span><br><span class="line">PlayerA_BF.area[<span class="number">8</span>][<span class="number">9</span>] = A;</span><br><span class="line">PlayerA_BF.area[<span class="number">9</span>][<span class="number">9</span>] = A;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Bug记录/SeaBattle</category>
      </categories>
      <tags>
        <tag>海战游戏</tag>
        <tag>策略</tag>
      </tags>
  </entry>
</search>
